---
title: "Mysql 基础(I)"
categories: ["Database"]
date: "2020-05-06"
last-modified: "2022-10-10"
brief-description: ""
---

import { Quotes } from "../src/components/Quotes.js";

数据库（Database）：保存有组织的数据的容器（通常是一个文件或一组文件），是通过数据库管理系统（DBMS）创建和操纵的容器。通常有两种类型：**关系型数据库**和**非关系型数据库**。

## 关系型数据库和非关系型数据库

|      类型      |                                               定义                                                |                                                                             优点                                                                             |                                      缺点                                      |             常见的数据库             |
| :------------: | :-----------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------: | :----------------------------------: |
|  关系型数据库  |                        以关系模型为基础，由多张能互相连接的表组成的数据库                         |                                              （1）表结构，格式一致便于维护；（2）使用 SQL 语句，可进行复杂查询                                               |     （1）读写性能差；（2）关系模型导致空间浪费；（3）表结构固定，灵活度低      | MySQL，SQL Server，Oracle，Sqlite 等 |
| 非关系型数据库 | NoSQL（Not Only SQL），指数据以对象的形式存储在数据库中，对象之间的关系通过每个对象自身的属性决定 | （1）可以以 key-value、文档、图片等多种形式的数据，应用场景更广；（2）海量数据较易维护；（3）可扩展、高并发、高稳定性、成本低；（4）可以实现数据的分布式处理 | （1）没有事务机制，无法确保数据的完整性和安全性；（2）功能没有关系型数据库完善 |       Redis，MongoDB，Hbase 等       |

## 数据类型

### 整数类型

| 类型名称      | 说明                                     | 存储需求               |
| ------------- | ---------------------------------------- | ---------------------- |
| TINYINT       | -128~127                                 | 0~255                  |
| SMALLINT      | -32768~32767                             | 0~65535                |
| MEDIUMINT     | -8388608~8388607                         | 0~16777215             |
| INT (INTEGER) | -2147483648~2147483647                   | 0~4294967295           |
| BIGINT        | -9223372036854775808~9223372036854775807 | 0~18446744073709551615 |

> 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。

### 小数类型

| 类型名称            | 说明               | 存储需求   |
| ------------------- | ------------------ | ---------- |
| FLOAT               | 单精度浮点数       | 4 个字节   |
| DOUBLE              | 双精度浮点数       | 8 个字节   |
| DECIMAL (M, D)，DEC | 压缩的“严格”定点数 | M+2 个字节 |

DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。

DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。

FLOAT 类型的取值范围如下：

-   有符号的取值范围：-3.402823466E+38 ～-1.175494351E-38。
-   无符号的取值范围：0 和 -1.175494351E-38 ～-3.402823466E+38。

DOUBLE 类型的取值范围如下：

-   有符号的取值范围：-1.7976931348623157E+308 ～-2.2250738585072014E-308。
-   无符号的取值范围：0 和 -2.2250738585072014E-308 ～-1.7976931348623157E+308。

> 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。

FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。

浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。

**在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。**

### 日期类型

| 类型名称  | 日期格式            | 日期范围                                          | 存储需求 |
| --------- | ------------------- | ------------------------------------------------- | -------- |
| YEAR      | YYYY                | 1901 ~ 2155                                       | 1 个字节 |
| TIME      | HH:MM:SS            | -838:59:59 ~ 838:59:59                            | 3 个字节 |
| DATE      | YYYY-MM-DD          | 1000-01-01 ~ 9999-12-3                            | 3 个字节 |
| DATETIME  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59         | 8 个字节 |
| TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC | 4 个字节 |

### 字符串类型

| 类型名称   | 说明                                           | 存储需求                                                        |
| ---------- | ---------------------------------------------- | --------------------------------------------------------------- |
| CHAR(M)    | 固定长度非二进制字符串                         | M 字节，1<=M<=255                                               |
| VARCHAR(M) | 变长非二进制字符串                             | L+1 字节，在此，L< = M 和 1<=M<=255                             |
| TINYTEXT   | 非常小的非二进制字符串                         | L+1 字节，在此，L<2^8                                           |
| TEXT       | 小的非二进制字符串                             | L+2 字节，在此，L<2^16                                          |
| MEDIUMTEXT | 中等大小的非二进制字符串                       | L+3 字节，在此，L<2^24                                          |
| LONGTEXT   | 大的非二进制字符串                             | L+4 字节，在此，L<2^32                                          |
| ENUM       | 枚举类型，只能有一个枚举字符串值               | 1 或 2 个字节，取决于枚举值的数目 (最大值为 65535)              |
| SET        | 一个设置，字符串对象可以有零个或 多个 SET 成员 | 1、2、3、4 或 8 个字节，取决于集合 成员的数量（最多 64 个成员） |

-   VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。

<Quotes
    quoteType="Note"
    title="Case study"
    message="一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。"
/>

#### CHAR 和 VARCHAR

CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0 ～ 255 个字符。

例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。

VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0 ～ 65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。

例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。

| 插入值   | CHAR(4) | 存储需求 | VARCHAR(4) | 存储需求 |
| -------- | ------- | -------- | ---------- | -------- |
| ' '      | ' '     | 4 字节   | ''         | 1 字节   |
| 'ab'     | 'ab '   | 4 字节   | 'ab'       | 3 字节   |
| 'abc'    | 'abc '  | 4 字节   | 'abc'      | 4 字节   |
| 'abcd'   | 'abcd'  | 4 字节   | 'abcd'     | 5 字节   |
| 'abcdef' | 'abcd'  | 4 字节   | 'abcd'     | 5 字节   |

对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。

#### TEXT

TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。

TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。

-   TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。
-   TEXT 表示长度为 65535（216-1）字符的 TEXT 列。
-   MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。
-   LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。

#### ENUM

ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：

```mysql
<字段名> ENUM( '值1', '值1', …, '值n' )
```

字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。

ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。

ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。

例如，定义 ENUM 类型的列（'first'，'second'，'third'），该列可以取的值和每个值的索引如下表所示。

| 值     | 索引 |
| ------ | ---- |
| NULL   | NULL |
| ''     | 0    |
| ’first | 1    |
| second | 2    |
| third  | 3    |

ENUM 值依照列**索引**顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。

> 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。

#### SET

SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号`,`隔开，语法格式如下：

```mysql
SET( '值1', '值2', …, '值n' )
```

与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。

但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。

> 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。

### 二进制类型

| 类型名称       | 说明                 | 存储需求               |
| -------------- | -------------------- | ---------------------- |
| BIT(M)         | 位字段类型           | 大约 (M+7)/8 字节      |
| BINARY(M)      | 固定长度二进制字符串 | M 字节                 |
| VARBINARY (M)  | 可变长度二进制字符串 | M+1 字节               |
| TINYBLOB (M)   | 非常小的 BLOB        | L+1 字节，在此，L<2^8  |
| BLOB (M)       | 小 BLOB              | L+2 字节，在此，L<2^16 |
| MEDIUMBLOB (M) | 中等大小的 BLOB      | L+3 字节，在此，L<2^24 |
| LONGBLOB (M)   | 非常大的 BLOB        | L+4 字节，在此，L<2^32 |

## 运算符

### 算术运算符

| 运算符 | 作用               | 使用方法                           |
| ------ | ------------------ | ---------------------------------- |
| +      | 加法运算           | 用于获得一个或多个值的和           |
| -      | 减法运算           | 用于从一个值中减去另一个值         |
| \*     | 乘法运算           | 使数字相乘，得到两个或多个值的乘积 |
| /      | 除法运算，返回商   | 用一个值除以另一个值得到商         |
| %，MOD | 求余运算，返回余数 | 用一个值除以另一个值得到余数       |

e.g.

```mysql
mysql> SELECT num,num+10,num-3+5,num+36.5 FROM temp;
+------+--------+---------+----------+
| num  | num+10 | num-3+5 | num+36.5 |
+------+--------+---------+----------+
|   64 |     74 |      66 |    100.5 |
+------+--------+---------+----------+
1 row in set (0.01 sec)
```

```mysql
mysql> SELECT num,num*2,num/2,num/3,num%3 FROM temp;
+------+-------+---------+---------+-------+
| num  | num*2 | num/2   | num/3   | num%3 |
+------+-------+---------+---------+-------+
|   64 |   128 | 32.0000 | 21.3333 |     1 |
+------+-------+---------+---------+-------+
1 row in set (0.00 sec)
```

-   四则运算中任意一个数为 NULL，结果为 NULL；
-   除数为 0 的除法是没有意义的。所以在除法运算和取余运算中，如果除数为 0，那么返回结果为 NULL。

### 逻辑运算符

| 运算符                                 | 作用     |
| -------------------------------------- | -------- |
| NOT 或者 !（优先级 '!' > '+' > 'NOT'） | 逻辑非   |
| AND 或者 &&                            | 逻辑与   |
| OR 和 \|\|                             | 逻辑或   |
| XOR                                    | 逻辑异或 |

#### 逻辑非运算

`NOT`和`!`都是逻辑非运算符，返回和操作数相反的结果，具体语法规则为：

-   当操作数为 0（假）时，返回值为 1；
-   当操作数为非零值时，返回值为 0；
-   **当操作数为 NULL 时，返回值为 NULL。**

```mysql
mysql> SELECT NOT 10,NOT(1-1),NOT-5,NOT NULL,NOT 1+1;
+--------+----------+-------+----------+---------+
| NOT 10 | NOT(1-1) | NOT-5 | NOT NULL | NOT 1+1 |
+--------+----------+-------+----------+---------+
|      0 |        1 |     0 |     NULL |       0 |
+--------+----------+-------+----------+---------+
1 row in set (0.00 sec)

mysql> SELECT !10,!(1-1),!-5,!NULL,!1+1;
+-----+--------+-----+-------+------+
| !10 | !(1-1) | !-5 | !NULL | !1+1 |
+-----+--------+-----+-------+------+
|   0 |      1 |   0 |  NULL |    1 |
+-----+--------+-----+-------+------+
1 row in set (0.00 sec)

mysql> SELECT !1+1;
+------+
| !1+1 |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

由运行结果可以看出，`NOT 1+1`和`! 1+1`的返回值不同，这是因为 NOT 与 ! 的优先级不同：

-   NOT 的优先级低于 +，因此`NOT 1+1`相当于`NOT(1+1)`，先计算`1+1`，然后再进行 NOT 运算，由于操作数不为 0，因此`NOT 1+1`的结果是 0；
-   相反，! 的优先级别要高于 +，因此`! 1+1`相当于`(!1)+1`，先计算`!1`结果为 0，再加 1，最后结果为 1。

**如果不能确定计算顺序，最好使用括号，以保证运算结果的正确。**

#### 逻辑与运算

AND 和 && 都是逻辑与运算符，具体语法规则为：

-   当所有操作数都为非零值并且不为 NULL 时，返回值为 1；
-   当一个或多个操作数为 0 时，返回值为 0；
-   操作数中有任何一个为 NULL 时且非 NULL 的操作数不为 0 时，返回值为 NULL。

```
mysql> SELECT 1 AND -1,1 AND 0,1 AND NULL, 0 AND NULL;
+----------+---------+------------+------------+
| 1 AND -1 | 1 AND 0 | 1 AND NULL | 0 AND NULL |
+----------+---------+------------+------------+
|        1 |       0 |       NULL |          0 |
+----------+---------+------------+------------+
1 row in set (0.00 sec)

mysql> SELECT 1 && -1,1&&0,1&&NULL,0&&NULL;
+---------+------+---------+---------+
| 1 && -1 | 1&&0 | 1&&NULL | 0&&NULL |
+---------+------+---------+---------+
|       1 |    0 |    NULL |       0 |
+---------+------+---------+---------+
1 row in set (0.00 sec)
```

#### 逻辑或运算

OR 和 || 都是逻辑或运算符，具体语法规则为：

-   当两个操作数都为非 NULL 值时，如果有任意一个操作数为非零值，则返回值为 1，否则结果为 0；
-   当有一个操作数为 NULL 时，如果另一个操作数为非零值，则返回值为 1，否则结果为 NULL；
-   假如两个操作数均为 NULL 时，则返回值为 NULL。

#### 异或运算

XOR 表示逻辑异或，具体语法规则为：

-   **当任意一个操作数为 NULL 时，返回值为 NULL；**
-   对于非 NULL 的操作数，如果两个操作数都是非 0 值或者都是 0 值，则返回值为 0；
-   如果一个为 0 值，另一个为非 0 值，返回值为 1。

### 比较运算符

当使用 SELECT 语句进行查询时，MYSQL 允许用户对表达式的左边操作数和右边操作数进行比较，比较结果为真，则返回 1，为假则返回 0，**比较结果不确定则返回 NULL**。

| 运算符              | 作用                         |
| ------------------- | ---------------------------- |
| `=`                 | 等于                         |
| `<=>`               | 安全的等于                   |
| `<>` 或者 `!=`      | 不等于                       |
| `<=`                | 小于等于                     |
| `>=`                | 大于等于                     |
| `>`                 | 大于                         |
| IS NULL 或者 ISNULL | 判断一个值是否为空           |
| IS NOT NULL         | 判断一个值是否不为空         |
| BETWEEN AND         | 判断一个值是否落在两个值之间 |

比较运算符可以用于比较数字、字符串和表达式的值。注意，**字符串的比较是不区分大小写的**。

#### 等于运算

= 运算符用来比较两边的操作数是否相等，相等的话返回 1，不相等的话返回 0。具体的语法规则如下：

-   **若有一个或两个操作数为 NULL，则比较运算的结果为 NULL。**
-   若两个操作数都是字符串，则按照字符串进行比较。
-   若两个操作数均为整数，则按照整数进行比较。
-   若一个操作数为字符串，另一个操作数为数字，则 MySQL 可以自动将字符串转换为数字（直接转换为数字，而不是 ASCII 码）。

#### 安全等于运算

`<=>` 操作符和 `=` 操作符类似，不过 `<=>` 可以用来判断 NULL 值，具体语法规则为：

-   当两个操作数均为 NULL 时，其返回值为 1 而不为 NULL；
-   而当一个操作数为 NULL 时，其返回值为 0 而不为 NULL。

```mysql
mysql> SELECT NULL<=>NULL, 1<=>NULL;
+-------------+----------+
| NULL<=>NULL | 1<=>NULL |
+-------------+----------+
|           1 |        0 |
+-------------+----------+
1 row in set (0.00 sec)
```

#### 不等于、小于等于、小于、大于等于、大于运算

**注意：如果两侧操作数有一个是 NULL，那么返回值也是 NULL。**

#### IS NULL(ISNULL), IS NOT NULL

IS NULL 或 ISNULL 运算符用来检测一个值是否为 NULL，如果为 NULL，返回值为 1，否则返回值为 0。ISNULL 可以认为是 IS NULL 的简写，去掉了一个空格而已，两者的作用和用法都是完全相同的。

IS NOT NULL 运算符用来检测一个值是否为非 NULL，如果是非 NULL，返回值为 1，否则返回值为 0。

#### BETWEEN AND

BETWEEN AND 运算符用来判断表达式的值是否位于两个数之间，或者说是否位于某个范围内，它的语法格式如下：

```mysql
expr BETWEEN min AND max
```

expr 表示要判断的表达式，min 表示最小值，max 表示最大值。如果 expr **大于等于** min **并且小于等于** max，那么返回值为 1，否则返回值为 0。

```mysql
mysql> SELECT 4 BETWEEN 2 AND 5,4 BETWEEN 4 AND 6,12 BETWEEN 9 AND 10;
+-------------------+-------------------+---------------------+
| 4 BETWEEN 2 AND 5 | 4 BETWEEN 4 AND 6 | 12 BETWEEN 9 AND 10 |
+-------------------+-------------------+---------------------+
|                 1 |                 1 |                   0 |
+-------------------+-------------------+---------------------+
1 row in set (0.00 sec)
```

```mysql
mysql> SELECT 'abc' BETWEEN 'aaaa' AND 'zzzz';
+---------------------------------+
| 'abc' BETWEEN 'aaaa' AND 'zzzz' |
+---------------------------------+
|                               1 |
+---------------------------------+
1 row in set (0.00 sec)
```

其实质为计算：

```mysql
expr >= min AND expr <= max
```

### 位运算符

MySQL 支持 6 种位运算符，如下表所示。

| 运算符 | 说明   | 使用形式 | 举例                             |
| ------ | ------ | -------- | -------------------------------- |
| \|     | 位或   | a \| b   | 5 \| 8                           |
| &      | 位与   | a & b    | 5 & 8                            |
| ^      | 位异或 | a ^ b    | 5 ^ 8                            |
| ~      | 位取反 | ~a       | ~5                               |
| <<     | 位左移 | a << b   | 5 << 2，表示整数 5 按位左移 2 位 |
| >>     | 位右移 | a >> b   | 5 >> 2，表示整数 5 按位右移 2 位 |

e.g.

```mysql
mysql> SELECT -7|-1;
+----------------------+
| -7|-1                |
+----------------------+
| 18446744073709551615 |
+----------------------+
1 row in set (0.00 sec)
```

-7 的补码为 60 个‘1’加 1001，-1 的补码为 64 个‘1’，按位或运算之后，结果为 64 个‘1’，即整数 18446744073709551615。

```
mysql> SELECT ~1,~18446744073709551614;
+----------------------+-----------------------+
| ~1                   | ~18446744073709551614 |
+----------------------+-----------------------+
| 18446744073709551614 |                     1 |
+----------------------+-----------------------+
1 row in set (0.00 sec)
```

常量 1 的补码为 63 个‘0‘加 1 个’1‘，位取反后就是 63 个’1‘加一个’0‘，转换为二进制后就是 18446744073709551614。

可以使用 **BIN() 函数**查看 1 取反之后的结果，BIN() 函数的作用是将一个十进制数转换为二进制数，SQL 语句如下:

```mysql
mysql> SELECT BIN(~1);
+------------------------------------------------------------------+
| BIN(~1)                                                          |
+------------------------------------------------------------------+
| 1111111111111111111111111111111111111111111111111111111111111110 |
+------------------------------------------------------------------+
1 row in set (0.01 sec)
```

1 的补码表示为最右边位为 1，其他位均为 0，取反操作之后，除了最低位，其他位均变为 1。

### 运算符优先级

| 优先级由低到高排列 | 运算符                                                                        |
| ------------------ | ----------------------------------------------------------------------------- |
| 1                  | =(赋值运算）、:=                                                              |
| 2                  | II、OR                                                                        |
| 3                  | XOR                                                                           |
| 4                  | &&、AND                                                                       |
| 5                  | NOT                                                                           |
| 6                  | BETWEEN、CASE、WHEN、THEN、ELSE                                               |
| 7                  | `=`（比较运算）、`<=>`、`>=`、`>`、`<=`、`<`、`<>`、!=、 IS、LIKE、REGEXP、IN |
| 8                  | \|                                                                            |
| 9                  | &                                                                             |
| 10                 | <<、>>                                                                        |
| 11                 | -(减号）、+                                                                   |
| 12                 | \*、/、%                                                                      |
| 13                 | ^                                                                             |
| 14                 | -(负号）、〜（位反转）                                                        |
| 15                 | !                                                                             |

### IN 和 NOT IN

IN 运算符用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0。

NOT IN 的作用和 IN 恰好相反，NOT IN 用来判断表达式的值是否不存在于给出的列表中；如果不是，返回值为 1，否则返回值为 0。

IN 和 NOT IN 的语法格式如下：

```mysql
expr IN ( value1, value2, value3 ... valueN )
expr NOT IN ( value1, value2, value3 ... valueN )
```

MySQL 会将 expr 的值和列表中的值逐一对比。

```mysql
mysql> SELECT 2 IN (1,3,5,'thks'),'thks' IN (1,3,5, 'thks');
+---------------------+---------------------------+
| 2 IN (1,3,5,'thks') | 'thks' IN (1,3,5, 'thks') |
+---------------------+---------------------------+
|                   0 |                         1 |
+---------------------+---------------------------+
1 row in set, 2 warnings (0.00 sec)

mysql> SELECT 2 NOT IN (1,3,5,'thks'),'thks' NOT IN (1,3,5, 'thks');
+-------------------------+-------------------------------+
| 2 NOT IN (1,3,5,'thks') | 'thks' NOT IN (1,3,5, 'thks') |
+-------------------------+-------------------------------+
|                       1 |                             0 |
+-------------------------+-------------------------------+
1 row in set, 2 warnings (0.00 sec)
```

#### 对 NULL 的处理

当 IN 运算符的两侧有一个为空值 NULL 时，如果找不到匹配项，则返回值为 NULL；如果找到了匹配项，则返回值为 1。

```mysql
mysql> SELECT NULL IN (1,3,5,'thks'),10 IN (1,3,NULL,'thks');
+------------------------+-------------------------+
| NULL IN (1,3,5,'thks') | 10 IN (1,3,NULL,'thks') |
+------------------------+-------------------------+
|                   NULL |                    NULL |
+------------------------+-------------------------+
1 row in set, 1 warning (0.00 sec)

mysql>  SELECT NULL IN (1,3,5,'thks'),10 IN (1,10,NULL,'thks');
+------------------------+--------------------------+
| NULL IN (1,3,5,'thks') | 10 IN (1,10,NULL,'thks') |
+------------------------+--------------------------+
|                   NULL |                        1 |
+------------------------+--------------------------+
1 row in set (0.00 sec)
```

NOT IN 恰好相反，当 NOT IN 运算符的两侧有一个为空值 NULL 时，如果找不到匹配项，则返回值为 NULL；如果找到了匹配项，则返回值为 0。

```mysql
mysql>  SELECT NULL NOT IN (1,3,5,'thks'),10 NOT IN (1,0,NULL,'thks');
+----------------------------+-----------------------------+
| NULL NOT IN (1,3,5,'thks') | 10 NOT IN (1,0,NULL,'thks') |
+----------------------------+-----------------------------+
|                       NULL |                        NULL |
+----------------------------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql>  SELECT NULL NOT IN (1,3,5,'thks'),10 NOT IN (1,10,NULL,'thks');
+----------------------------+------------------------------+
| NULL NOT IN (1,3,5,'thks') | 10 NOT IN (1,10,NULL,'thks') |
+----------------------------+------------------------------+
|                       NULL |                            0 |
+----------------------------+------------------------------+
1 row in set (0.00 sec)
```

## SQL 语句分类

|   语句类型   |              英文               |                  举例                   |                  说明                  |
| :----------: | :-----------------------------: | :-------------------------------------: | :------------------------------------: |
| 数据定义语言 |  DDL, Data Definition Language  |        `CREATE`, `DROP`, `ALTER`        |      对视图、表、索引结构进行操作      |
| 数据查询语言 |    DQL, Data Query Language     |                `SELECT`                 |            包括各种查询语句            |
| 数据操纵语言 | DML, Data Manipulation Language |      `INSERT`, `UPDATE`, `DELETE`       |     对 DQL 一样，都是数据进行操作      |
| 数据控制语言 |   DCL, Data Control Language    | `GRANT`, `REVOKE`, `COMMIT`, `ROLLBACK` | 权限控制，对数据库安全性、完整性的操作 |

## 数据库操作

### 创建数据库

语法格式：

```mysql
CREATE DATABASE [IF NOT EXISTS] <数据库名>
[[DEFAULT] CHARACTER SET <字符集名>]
[[DEFAULT] COLLATE <校对规则名>];
```

-   IF NOT EXIST： 只有该数据库目前尚不存在时才能执行操作；
-   [DEFAULT] CHARACTER SET：指定数据库的字符集，避免出现乱码；
-   [DEFAULT] COLLATE：指定字符集的默认校对规则。

### 查看数据库

#### 查看所有数据库

```mysql
SHOW DATABASES [LIKE '数据库名'];
```

默认数据库如下：

```powershell
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| sys                |
| world              |
+--------------------+
```

-   information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。
-   mysql：MySQL 的**核心数据库**，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。
-   performance_schema：主要用于收集数据库服务器**性能参数**。
-   sakila：MySQL 提供的**样例**数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。
-   sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。
-   world：world 数据库是 MySQL 自动创建的数据库，该数据库中只包括 3 张数据表，分别保存城市，国家和国家使用的**语言**等内容。

#### 使用 LIKE

使用 LIKE 从句，查看名字中包含 db 的数据库：

```mysql
SHOW DATABASES LIKE '%db%';
```

百分号作为通配符。

### 查看数据库定义声明

```mysql
SHOW CREATE DATABASE [数据库名];
```

### 修改数据库

语法：

```mysql
ALTER DATABASE [数据库名]
[[ DEFAULT ] CHARACTER SET <字符集名>]
[[ DEFAULT ] COLLATE <校对规则名>];
```

-   ALTER DATABASE 用于更改数据库的全局特性。
-   使用 ALTER DATABASE 需要获得数据库 ALTER 权限。
-   数据库名称可以忽略，此时语句对应于默认数据库。
-   CHARACTER SET 子句用于更改默认的数据库字符集。

### 删除数据库

语法：

```mysql
DROP DATABASE [IF EXISTS] <数据库名>
```

-   IF EXISTS：用于防止当数据库不存在时发生错误。
-   DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。

**注意：MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。**

DROP DATABASE 删除数据库后，数据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。因此最好在删除数据库之前先将数据库进行备份。

### 选择数据库

语法：

```mysql
USE <数据库名>
```

该语句可以通知 MySQL 把`<数据库名>`所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。

只有使用 USE 语句来指定某个数据库作为当前数据库之后，才能对该数据库及其存储的数据对象执行操作。

## 数据表操作

### 创建数据表

```mysql
CREATE TABLE <表名> ([表定义选项])[表选项][分区选项];
```

`[表定义选项]`的格式为：

```mysql
<列名1> <类型1> [,…] <列名n> <类型n>
```

-   <表名>：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。
    表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。
    在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，'mydb'.'mytbl' 是合法的，但 'mydb.mytbl' 不合法。
-   <表定义选项>：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。
-   默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。

> 提示：使用 CREATE TABLE 创建表时，必须指定以下信息：
>
> -   要创建的表的名称不区分大小写，不能使用 SQL 语言中的关键字，如 DROP、ALTER、INSERT 等。
> -   数据表中每个列（字段）的名称和数据类型，如果创建多个列，要用逗号隔开。

e.g.

```mysql
mysql> USE test_db;
Database changed
mysql> CREATE TABLE tb_emp1
    -> (
    -> id INT(11),
    -> name VARCHAR(25),
    -> deptId INT(11),
    -> salary FLOAT
    -> );
```

### 查看数据表

使用 SHOW TABLES 语句查看数据表是否创建成功。

DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下：

```mysql
DESCRIBE <表名>;
# 或 DESC <表名>;

e.g.
mysql> DESC tb_emp1;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | YES  |     | NULL    |       |
| name   | varchar(25) | YES  |     | NULL    |       |
| deptId | int(11)     | YES  |     | NULL    |       |
| salary | float       | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

-   Null：表示该列是否可以存储 NULL 值。
-   Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。
-   Default：表示该列是否有默认值，如果有，值是多少。
-   Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。

SHOW CREATE TABLE 语句可以用来显示创建表时的 CREATE TABLE 语句，语法格式如下：

```mysql
SHOW CREATE TABLE <表名>\G	# 没有分号
```

使用 SHOW CREATE TABLE 语句不仅可以查看创建表时的详细语句，而且可以查看存储引擎和字符编码。如果不加“\G”参数，显示的结果可能非常混乱，加上“\G”参数之后，可使显示的结果更加直观，易于查看。

### 修改数据表

```mysql
ALTER TABLE <表名> [修改选项]
```

修改选项的语法格式如下：

```mysql
{ ADD COLUMN <列名> <类型>
| CHANGE COLUMN <旧列名> <新列名> <新列类型>
| ALTER COLUMN <列名> { SET DEFAULT <默认值> | DROP DEFAULT }
| MODIFY COLUMN <列名> <类型>
| DROP COLUMN <列名>
| RENAME TO <新表名>
| CHARACTER SET <字符集名>
| COLLATE <校对规则名> }
```

#### 修改表名

```mysql
ALTER TABLE <旧表名> RENAME [TO] <新表名>；
```

TO 为可选参数，使用与否均不影响结果。

#### 修改表字符集

```mysql
ALTER TABLE 表名 [DEFAULT] CHARACTER SET <字符集名> [DEFAULT] COLLATE <校对规则名>;
```

DEFAULT 为可选参数，使用与否均不影响结果。

#### 修改/删除字段

```mysql
ALTER TABLE <表名> CHANGE <旧字段名> <新字段名> <新数据类型>；
```

新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型**不能为空**。

CHANGE 也可以只修改数据类型，实现和 MODIFY 同样的效果，方法是将 SQL 语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”。

> 提示：由于不同类型的数据在机器中的存储方式及长度并不相同，修改数据类型可能会影响数据表中已有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。

#### 修改字段数据类型

```mysql
ALTER TABLE <表名> MODIFY <字段名> <数据类型>
```

#### 删除字段

```mysql
ALTER TABLE <表名> DROP <字段名>；
```

### 删除数据表

```mysql
DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...]
```

### 删除被其它表关联的主表

删除被数据表 tb_emp5 关联的数据表 tb_emp4，SQL 语句如下：

```mysql
mysql> DROP TABLE tb_emp4;
ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails
```

当主表在存在外键约束时，不能被直接删除。

下面解除子表 tb_emp5 的外键约束，SQL 语句和运行结果如下：

```mysql
mysql> ALTER TABLE tb_emp5 DROP FOREIGN KEY fk_emp4_emp5;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

语句成功执行后，会取消表 tb_emp4 和表 tb_emp5 之间的关联关系。

解除关联关系后，可以使用 DROP TABLE 语句直接删除父表 tb_emp4，SQL 语句如下：

```mysql
DROP TABLE tb_emp4;
```

### 添加字段（三种方式）

#### 在末尾添加字段

```mysql
ALTER TABLE <表名> ADD <新字段名><数据类型>[约束条件];
```

#### 在开头添加字段

MySQL 默认在表的最后位置添加新字段，如果希望在开头位置（第一列的前面）添加新字段，那么可以使用 FIRST 关键字，语法格式如下：

```mysql
ALTER TABLE <表名> ADD <新字段名> <数据类型> [约束条件] FIRST;
```

#### 在中间位置添加字段

```mysql
ALTER TABLE <表名> ADD <新字段名> <数据类型> [约束条件] AFTER <已经存在的字段名>;
```

AFTER 的作用是将新字段添加到某个已有字段后面。只能在某个已有字段的后面添加新字段，不能在它的前面添加新字段。

## 约束

### 主键

主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。

主键应该遵守下面的规则：

-   每个表只能定义一个主键。
-   主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是**唯一性原则**。
-   一个列名只能在复合主键列表中出现一次。
-   复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是**最小化原则**。

1. 在定义列的同时指定主键，语法规则如下：

```mysql
<字段名> <数据类型> PRIMARY KEY [默认值]
```

e.g.

```mysql
mysql> CREATE TABLE tb_emp3
    -> (
    -> id INT(11) PRIMARY KEY,
    -> name VARCHAR(25),
    -> deptId INT(11),
    -> salary FLOAT
    -> );
```

2. 在定义完所有列之后，指定主键的语法格式为：

```mysql
[CONSTRAINT <约束名>] PRIMARY KEY [字段名]
```

#### 复合主键

主键由多个字段联合组成，语法规则如下：

```mysql
PRIMARY KEY (字段1，字段2，…,字段n)
```

创建数据表 tb_emp5，假设表中没有主键 id，为了唯一确定一个员工，可以把 name、deptId 联合起来作为主键，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> CREATE TABLE tb_emp5
    -> (
    -> name VARCHAR(25),
    -> deptId INT(11),
    -> salary FLOAT,
    -> PRIMARY KEY(id,deptId)
    -> );
Query OK, 0 rows affected (0.37 sec)
mysql> DESC tb_emp5;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| name   | varchar(25) | NO   | PRI | NULL    |       |
| deptId | int(11)     | NO   | PRI | NULL    |       |
| salary | float       | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
3 rows in set (0.14 sec)
```

#### 修改表时添加主键约束

```mysql
ALTER TABLE <数据表名> ADD PRIMARY KEY(<列名>);
```

查看 tb_emp2 数据表的表结构，如下所示。

```mysql
mysql> DESC tb_emp2;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   |     | NULL    |       |
| name   | varchar(30) | YES  |     | NULL    |       |
| deptId | int(11)     | YES  |     | NULL    |       |
| salary | float       | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.14 sec)
```

修改数据表 tb_emp2，将字段 id 设置为主键，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> ALTER TABLE tb_emp2
    -> ADD PRIMARY KEY(id);
Query OK, 0 rows affected (0.94 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tb_emp2;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   | PRI | NULL    |       |
| name   | varchar(30) | YES  |     | NULL    |       |
| deptId | int(11)     | YES  |     | NULL    |       |
| salary | float       | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.12 sec)
```

### 外键

外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。

外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。

外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。

-   主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。
-   从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。

定义一个外键时，需要遵守下列规则：

-   父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。
-   必须为父表定义主键。
-   主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。
-   在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。
-   外键中列的数目必须和父表的主键中列的数目相同。
-   外键中列的**数据类型**必须和父表主键中对应列的数据类型相同。

在数据表中创建外键使用 **FOREIGN KEY** 关键字，具体的语法规则如下：

```mysql
[CONSTRAINT <外键约束名>]
FOREIGN KEY 字段名 [，字段名2，…] REFERENCES <主表名> 主键列1 [，主键列2，…]
```

其中：`外键约束名`为定义的外键约束的名称，一个表中不能有相同名称的外键约束；`字段名`表示子表需要添加外健约束的字段列；`主表名`即被子表外键所依赖的表的名称；`主键列`表示主表中定义的主键列或者列组合。

e.g.

```mysql
mysql> CREATE TABLE tb_emp6
    -> (
    -> id INT(11) PRIMARY KEY,
    -> name VARCHAR(25),
    -> deptId INT(11),
    -> salary FLOAT,
    -> CONSTRAINT fk_emp_dept1
    -> FOREIGN KEY(deptId) REFERENCES tb_dept1(id)
    -> );
Query OK, 0 rows affected (0.37 sec)
mysql> DESC tb_emp6;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int(11)     | NO   | PRI | NULL    |       |
| name   | varchar(25) | YES  |     | NULL    |       |
| deptId | int(11)     | YES  | MUL | NULL    |       |
| salary | float        | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (1.33 sec)
```

#### 在修改表时添加外键约束

```mysql
ALTER TABLE <数据表名>
ADD CONSTRAINT <外键约束名>
FOREIGN KEY(<列名>)
REFERENCES <主表名> (<列名>);
```

修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> ALTER TABLE tb_emp2
    -> ADD CONSTRAINT fk_tb_dept1
    -> FOREIGN KEY(deptId)
    -> REFERENCES tb_dept1(id);
Query OK, 0 rows affected (1.38 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW CREATE TABLE tb_emp2\G
*************************** 1. row ***************************
       Table: tb_emp2
Create Table: CREATE TABLE `tb_emp2` (
  `id` int(11) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `deptId` int(11) DEFAULT NULL,
  `salary` float DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_tb_dept1` (`deptId`),
  CONSTRAINT `fk_tb_dept1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=gb2312
1 row in set (0.12 sec)
```

#### 删除外键约束

对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下：

```mysql
ALTER TABLE <表名>
DROP FOREIGN KEY <外键约束名>;
```

删除数据表 tb_emp2 中的外键约束 fk_tb_dept1，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> ALTER TABLE tb_emp2
    -> DROP FOREIGN KEY fk_tb_dept1;
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW CREATE TABLE tb_emp2\G
*************************** 1. row ***************************
       Table: tb_emp2
Create Table: CREATE TABLE `tb_emp2` (
  `id` int(11) NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `deptId` int(11) DEFAULT NULL,
  `salary` float DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_tb_dept1` (`deptId`)
) ENGINE=InnoDB DEFAULT CHARSET=gb2312
1 row in set (0.00 sec)
```

### 唯一约束

唯一约束（Unique Key）要求该列唯一，允许为空，但**只能出现一个空值**。唯一约束可以确保一列或者几列不出现重复值。

在定义完列之后直接使用 **UNIQUE** 关键字指定唯一约束，语法规则如下：

```mysql
<字段名> <数据类型> UNIQUE
```

创建数据表 tb_dept2，指定部门的名称唯一，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> CREATE TABLE tb_dept2
    -> (
    -> id INT(11) PRIMARY KEY,
    -> name VARCHAR(22) UNIQUE,
    -> location VARCHAR(50)
    -> );
Query OK, 0 rows affected (0.37 sec)
mysql> DESC tb_dept2;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id       | int(11)     | NO   | PRI | NULL    |       |
| name     | varchar(40) | YES  | UNI | NULL    |       |
| location | varchar(50) | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
3 rows in set (0.08 sec)
```

> 提示：UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。

#### 修改表时添加唯一约束

在修改表时添加唯一约束的语法格式为：

```mysql
ALTER TABLE <数据表名> ADD CONSTRAINT <唯一约束名> UNIQUE(<列名>);
```

e.g.

```mysql
mysql> ALTER TABLE tb_dept1
    -> ADD CONSTRAINT unique_name UNIQUE(name);
Query OK, 0 rows affected (0.63 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tb_dept1;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id       | int(11)     | NO   | PRI | NULL    |       |
| name     | varchar(22) | NO   | UNI | NULL    |       |
| location | varchar(50) | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

#### 删除唯一约束

在 MySQL 中删除唯一约束的语法格式如下：

```mysql
ALTER TABLE <表名> DROP INDEX <唯一约束名>;
```

删除数据表 tb_dept1 中的唯一约束 unique_name，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> ALTER TABLE tb_dept1
    -> DROP INDEX unique_name;
Query OK, 0 rows affected (0.20 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tb_dept1;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id       | int(11)     | NO   | PRI | NULL    |       |
| name     | varchar(22) | NO   |     | NULL    |       |
| location | varchar(50) | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

### 检查约束

```mysql
CHECK(<检查约束>)
```

其中：`<表达式>`指的就是 SQL 表达式，用于指定需要检查的限定条件。

若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK 约束。

在更新表数据的时候，系统会检查更新后的数据行是否满足 CHECK 约束中的限定条件。MySQL 可以使用简单的表达式来实现 CHECK 约束，也允许使用复杂的表达式作为限定条件，例如在限定条件中加入子查询。

> 注意：若将 CHECK 约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束。该约束可以同时对表中多个列设置限定条件。

e.g.

在 test_db 数据库中创建 tb_emp7 数据表，要求 salary 字段值大于 0 且小于 10000，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> CREATE TABLE tb_emp7
    -> (
    -> id INT(11) PRIMARY KEY,
    -> name VARCHAR(25),
    -> deptId INT(11),
    -> salary FLOAT,
    -> CHECK(salary>0 AND salary<100),
    -> FOREIGN KEY(deptId) REFERENCES tb_dept1(id)
    -> );
Query OK, 0 rows affected (0.37 sec)
```

#### 修改表时添加检查约束

修改表时设置检查约束的语法规则如下：

```mysql
ALTER TABLE tb_emp7
ADD CONSTRAINT <检查约束名>
CHECK(<检查约束>)
```

修改 tb_dept 数据表，要求 id 字段值大于 0，输入的 SQL 语句和运行结果如下所示。

```
mysql> ALTER TABLE tb_emp7
    -> ADD CONSTRAINT check_id
    -> CHECK(id>0);
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

#### 删除检查约束

修改表时删除检查约束的语法规则如下：

```mysql
ALTER TABLE <数据表名> DROP CONSTRAINT <检查约束名>;
```

### 默认值约束

```mysql
<字段名> <数据类型> DEFAULT <默认值>;
```

e.g.

```
mysql> CREATE TABLE tb_dept3
    -> (
    -> id INT(11) PRIMARY KEY,
    -> name VARCHAR(22),
    -> location VARCHAR(50) DEFAULT 'Beijing'
    -> );
Query OK, 0 rows affected (0.37 sec)
mysql> DESC tb_dept3;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id       | int(11)     | NO   | PRI | NULL    |       |
| name     | varchar(22) | YES  |     | NULL    |       |
| location | varchar(50) | YES  |     | Beijing |       |
+----------+-------------+------+-----+---------+-------+
3 rows in set (0.06 sec)
```

#### 在修改表时添加默认值约束

```mysql
ALTER TABLE <数据表名>
CHANGE COLUMN <字段名> <数据类型> DEFAULT <默认值>;
```

修改数据表 tb_dept3，将部门位置的默认值修改为 Shanghai，输入的 SQL 语句和运行结果如下所示。

```mysql
mysql> ALTER TABLE tb_dept3
    -> CHANGE COLUMN location
    -> location VARCHAR(50) DEFAULT 'Shanghai';
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> DESC tb_dept3;
+----------+-------------+------+-----+----------+-------+
| Field    | Type        | Null | Key | Default  | Extra |
+----------+-------------+------+-----+----------+-------+
| id       | int(11)     | NO   | PRI | NULL     |       |
| name     | varchar(22) | YES  |     | NULL     |       |
| location | varchar(50) | YES  |     | Shanghai |       |
+----------+-------------+------+-----+----------+-------+
3 rows in set (0.00 sec)
```

#### 删除默认值约束

修改表时删除默认值约束的语法规则如下：

```mysql
ALTER TABLE <数据表名>
CHANGE COLUMN <字段名>
<字段名> <数据类型> DEFAULT NULL;
```

### 非空约束

非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。

```mysql
<字段名> <数据类型> NOT NULL;
```

#### 修改表时添加非空约束

```mysql
ALTER TABLE <数据表名>
CHANGE COLUMN <字段名>
<字段名> <数据类型> NOT NULL;
```

#### 删除非空约束

```mysql
ALTER TABLE <数据表名>
CHANGE COLUMN <字段名>
<字段名> <数据类型> NULL;
```

### 查看约束

```mysql
SHOW CREATE TABLE <数据表名>;
```

## 操作表中数据（DML）

### 查询

```mysql
SELECT
{* | <字段列名>}
[
FROM <表 1>, <表 2>…
[WHERE <表达式>
[GROUP BY <group by definition>
[HAVING <expression> [{<operator> <expression>}…]]
[ORDER BY <order by definition>]
[LIMIT[<offset>,] <row count>]
]
```

其中，各条子句的含义如下：

-   `{*|<字段列名>}`包含星号通配符的字段列表，表示所要查询字段的名称。
-   `<表 1>，<表 2>…`，表 1 和表 2 表示查询数据的来源，可以是单个或多个。
-   `WHERE <表达式>`是可选项，如果选择该项，将限定查询数据必须满足该查询条件。
-   `GROUP BY< 字段 >`，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。
-   `[ORDER BY< 字段 >]`，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。
-   `[LIMIT[，]]`，该子句告诉 MySQL 每次显示查询出来的数据条数。

#### 查询所有字段

```mysql
SELECT * FROM 表名;
```

#### 查询指定字段

```mysql
SELECT <字段名> FROM <表名>;
SELECT <字段名1>,<字段名2>,…,<字段名n> FROM <表名>;
```

#### DISTINCT 去重

```mysql
SELECT DISTINCT <字段名> FROM <表名>;
```

使用 DISTINCT 关键字时需要注意以下几点：

-   DISTINCT 关键字只能在 SELECT 语句中使用。
-   在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。
-   如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。

```mysql
mysql> SELECT * FROM test.student;
+----+----------+------+-------+
| id | name     | age  | stuno |
+----+----------+------+-------+
|  1 | zhangsan |   18 |    23 |
|  2 | lisi     |   19 |    24 |
|  3 | wangwu   |   18 |    25 |
|  4 | zhaoliu  |   18 |    26 |
|  5 | zhangsan |   18 |    27 |
|  6 | wangwu   |   20 |    28 |
+----+----------+------+-------+
6 rows in set (0.00 sec)
```

对 student 表的 age 字段进行去重，SQL 语句和运行结果如下：

```mysql
mysql> SELECT DISTINCT age FROM student;
+------+
| age  |
+------+
|   18 |
|   19 |
|   20 |
+------+
3 rows in set (0.00 sec)
```

对 student 表的 name 和 age 字段进行组合去重，SQL 语句和运行结果如下：

```mysql
mysql> SELECT DISTINCT name,age FROM student;
+----------+------+
| name     | age  |
+----------+------+
| zhangsan |   18 |
| lisi     |   19 |
| wangwu   |   18 |
| zhaoliu  |   18 |
| wangwu   |   20 |
+----------+------+
5 rows in set (0.00 sec)
```

对 student 表中的所有字段进行去重，SQL 语句和运行结果如下：

```mysql
mysql> SELECT DISTINCT * FROM student;
+----+----------+------+-------+
| id | name     | age  | stuno |
+----+----------+------+-------+
|  1 | zhangsan |   18 |    23 |
|  2 | lisi     |   19 |    24 |
|  3 | wangwu   |   18 |    25 |
|  4 | zhaoliu  |   18 |    26 |
|  5 | zhangsan |   18 |    27 |
|  6 | wangwu   |   20 |    28 |
+----+----------+------+-------+
6 rows in set (0.00 sec)
```

因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。

查询 student 表中对 name 和 age 字段去重之后记录的条数，SQL 语句和运行结果如下：

```mysql
mysql> SELECT COUNT(DISTINCT name,age) FROM student;
+--------------------------+
| COUNT(DISTINCT name,age) |
+--------------------------+
|                        5 |
+--------------------------+
1 row in set (0.01 sec)
```

#### LIMIT 限制查询条数

LIMIT 是 MySQL 中的一个特殊关键字，用于指定查询结果从哪条记录开始显示，一共显示多少条记录。

LIMIT 关键字有 3 种使用方式，即指定初始位置、不指定初始位置以及与 OFFSET 组合使用。

##### 指定初始位置

```mysql
LIMIT 初始位置，记录数
```

初始位置”表示从哪条记录开始显示；“记录数”表示显示记录的条数。第一条记录的位置是 0，第二条记录的位置是 1。后面的记录依次类推。

**注意：LIMIT 后的两个参数必须都是正整数。**

```mysql
mysql> SELECT * FROM tb_students_info LIMIT 3,5;
+----+-------+---------+------+------+--------+------------+
| id | name  | dept_id | age  | sex  | height | login_date |
+----+-------+---------+------+------+--------+------------+
|  4 | Jane  |       1 |   22 | F    |    162 | 2016-12-20 |
|  5 | Jim   |       1 |   24 | M    |    175 | 2016-01-15 |
|  6 | John  |       2 |   21 | M    |    172 | 2015-11-11 |
|  7 | Lily  |       6 |   22 | F    |    165 | 2016-02-26 |
|  8 | Susan |       4 |   23 | F    |    170 | 2015-10-01 |
+----+-------+---------+------+------+--------+------------+
5 rows in set (0.00 sec)
```

##### 不指定初始位置

```mysql
LIMIT 记录数
```

如果“记录数”的值小于查询结果的总数，则会从第一条记录开始，显示指定条数的记录。如果“记录数”的值大于查询结果的总数，则会直接显示查询出来的所有记录。

`LIMIT n` 与 `LIMIT 0，n` 返回结果相同。

```mysql
mysql> SELECT * FROM tb_students_info LIMIT 4;
+----+-------+---------+------+------+--------+------------+
| id | name  | dept_id | age  | sex  | height | login_date |
+----+-------+---------+------+------+--------+------------+
|  1 | Dany  |       1 |   25 | F    |    160 | 2015-09-10 |
|  2 | Green |       3 |   23 | F    |    158 | 2016-10-22 |
|  3 | Henry |       2 |   23 | M    |    185 | 2015-05-31 |
|  4 | Jane  |       1 |   22 | F    |    162 | 2016-12-20 |
+----+-------+---------+------+------+--------+------------+
4 rows in set (0.00 sec)
```

##### LIMIT 和 OFFSET 组合使用

```mysql
LIMIT 记录数 OFFSET 初始位置
```

`LIMIT n OFFSET 0` 和 `LIMIT 0, n` 等价。

#### ORDER BY 排序

```mysql
ORDER BY <字段名> [ASC|DESC]
```

-   字段名：表示需要排序的字段名称，多个字段时用逗号隔开。
-   ASC|DESC：`ASC`表示字段按升序排序；`DESC`表示字段按降序排序。其中`ASC`为默认值。

使用 ORDER BY 关键字应该注意以下几个方面：

-   ORDER BY 关键字后可以跟子查询（关于子查询后面教程会详细讲解，这里了解即可）。
-   当排序的字段中存在空值时，ORDER BY 会将该空值作为最小值来对待。
-   ORDER BY 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序。

e.g.

```mysql
mysql> SELECT * FROM tb_students_info ORDER BY height;
+----+--------+---------+------+------+--------+------------+
| id | name   | dept_id | age  | sex  | height | login_date |
+----+--------+---------+------+------+--------+------------+
|  2 | Green  |       3 |   23 | F    |    158 | 2016-10-22 |
|  1 | Dany   |       1 |   25 | F    |    160 | 2015-09-10 |
|  4 | Jane   |       1 |   22 | F    |    162 | 2016-12-20 |
|  7 | Lily   |       6 |   22 | F    |    165 | 2016-02-26 |
| 10 | Tom    |       4 |   23 | M    |    165 | 2016-08-05 |
|  8 | Susan  |       4 |   23 | F    |    170 | 2015-10-01 |
|  6 | John   |       2 |   21 | M    |    172 | 2015-11-11 |
|  5 | Jim    |       1 |   24 | M    |    175 | 2016-01-15 |
|  9 | Thomas |       3 |   22 | M    |    178 | 2016-06-07 |
|  3 | Henry  |       2 |   23 | M    |    185 | 2015-05-31 |
+----+--------+---------+------+------+--------+------------+
10 rows in set (0.08 sec)
```

```mysql
mysql> SELECT name,height FROM tb_students_info ORDER BY height,name;
+--------+--------+
| name   | height |
+--------+--------+
| Green  |    158 |
| Dany   |    160 |
| Jane   |    162 |
| Lily   |    165 |
| Tom    |    165 |
| Susan  |    170 |
| John   |    172 |
| Jim    |    175 |
| Thomas |    178 |
| Henry  |    185 |
+--------+--------+
10 rows in set (0.09 sec)
```

```mysql
mysql> SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;
+--------+--------+
| name   | height |
+--------+--------+
| Henry  |    185 |
| Thomas |    178 |
| Jim    |    175 |
| John   |    172 |
| Susan  |    170 |
| Lily   |    165 |
| Tom    |    165 |
| Jane   |    162 |
| Dany   |    160 |
| Green  |    158 |
+--------+--------+
10 rows in set (0.00 sec)
```

查询 tb_students_info 表，先按 height 降序排序，再按 name 升序排序。

#### WHERE 条件

使用 WHERE 关键字的语法格式如下：

```mysql
WHERE 查询条件
```

查询条件可以是：

-   带比较运算符和逻辑运算符的查询条件
-   带 BETWEEN AND 关键字的查询条件
-   带 IS NULL 关键字的查询条件
-   带 IN 关键字的查询条件
-   带 LIKE 关键字的查询条件

```mysql
mysql> SELECT name,age FROM tb_students_info
    -> WHERE age<22;
```

```mysql
mysql> SELECT name,age,height FROM tb_students_info
    -> WHERE age>21 XOR height>=175;
```

#### LIKE 模糊查询

```mysql
[NOT] LIKE  '字符串'
```

其中：

-   NOT ：可选参数，字段中的内容与指定的字符串不匹配时满足条件。
-   字符串：指定用来匹配的字符串。“字符串”可以是一个很完整的字符串，也可以包含通配符。

LIKE 关键字支持百分号“%”和下划线“\_”通配符。

##### % 通配符

“%”是 MySQL 中最常用的通配符，它能代表**任何长度的字符串，字符串的长度可以为 0**。例如，`a%b`表示以字母 a 开头，以字母 b 结尾的任意长度的字符串。该字符串可以代表 ab、acb、accb、accrb 等字符串。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE name LIKE '%e%';
+-------+
| name  |
+-------+
| Green |
| Henry |
| Jane  |
+-------+
3 rows in set (0.00 sec)
```

##### \_ 通配符

“\_”只能代表单个字符，字符的长度不能为 0。例如，`a_b`可以代表 acb、adb、aub 等字符串。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE name LIKE '____y';
+-------+
| name  |
+-------+
| Henry |
+-------+
1 row in set (0.00 sec)
```

##### BINARY 区分大小写

```mysql
mysql> SELECT name FROM tb_students_info WHERE name LIKE 't%';
+--------+
| name   |
+--------+
| Thomas |
| Tom    |
+--------+
2 rows in set (0.00 sec)

mysql> SELECT name FROM tb_students_info WHERE name LIKE BINARY 't%';
Empty set (0.01 sec)
```

##### \ 通配符转义

```mysql
mysql> SELECT NAME FROM test.`tb_students_info` WHERE NAME LIKE '%\%';
+-------+
| NAME  |
+-------+
| Dany% |
+-------+
1 row in set (0.00 sec)
```

##### 通配符注意事项

下面是使用通配符的一些注意事项：

-   **注意大小写**。MySQL 默认是不区分大小写的。如果区分大小写，像“Tom”这样的数据就不能被“t%”所匹配到。
-   **注意尾部空格**，尾部空格会干扰通配符的匹配。例如，“T% ”就不能匹配到“Tom”。
-   **注意 NULL**。“%”通配符可以到匹配任意字符，但是不能匹配 NULL。也就是说 “%”匹配不到 tb_students_info 数据表中值为 NULL 的记录。

下面是一些使用通配符要记住的技巧。

-   不要过度使用通配符，如果其它操作符能达到相同的目的，应该使用其它操作符。因为 MySQL 对通配符的处理一般会比其他操作符花费更长的时间。
-   在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。
-   仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。

#### BETWEEN AND 范围查询

```mysql
[NOT] BETWEEN 取值1 AND 取值2
```

```mysql
mysql> SELECT name,login_date FROM tb_students_info
    -> WHERE login_date BETWEEN '2015-10-01' AND '2016-05-01';
+-------+------------+
| name  | login_date |
+-------+------------+
| Jim   | 2016-01-15 |
| John  | 2015-11-11 |
| Lily  | 2016-02-26 |
| Susan | 2015-10-01 |
+-------+------------+
4 rows in set (0.00 sec)
```

#### IS NULL 空值查询

```mysql
IS [NOT] NULL
```

```mysql
mysql> SELECT `name`,`login_date` FROM tb_students_info
    -> WHERE login_date IS NULL;
+--------+------------+
| NAME   | login_date |
+--------+------------+
| Dany   | NULL       |
| Green  | NULL       |
| Henry  | NULL       |
| Jane   | NULL       |
| Thomas | NULL       |
| Tom    | NULL       |
+--------+------------+
6 rows in set (0.01 sec)
```

```mysql
mysql> SELECT `name`,login_date FROM tb_students_info
    -> WHERE login_date IS NOT NULL;
+-------+------------+
| name  | login_date |
+-------+------------+
| Jim   | 2016-01-15 |
| John  | 2015-11-11 |
| Lily  | 2016-02-26 |
| Susan | 2015-10-01 |
+-------+------------+
4 rows in set (0.00 sec)
```

注意：`IS NULL` 是一个整体，不能将 `IS` 换成“`=`”。如果将 IS 换成`=`将不能查询出任何结果，数据库系统会出现`Empty set(0.00 sec)`这样的提示。同理，`IS NOT NULL` 中的 `IS NOT` 不能换成“`!=`”或“`<>`”。

#### GROUP BY 分组查询

在 MySQL 中，GROUP BY 关键字可以根据一个或多个字段对查询结果进行分组。

使用 GROUP BY 关键字的语法格式如下：

```mysql
GROUP BY <字段名>
```

其中，“字段名”表示需要分组的字段名称，多个字段时用逗号隔开。

单独使用 GROUP BY 关键字时，查询结果会只显示每个分组的第一条记录。

```mysql
mysql> SELECT `name`,`sex` FROM tb_students_info
    -> GROUP BY sex;
+-------+------+
| name  | sex  |
+-------+------+
| Henry | 女   |
| Dany  | 男   |
+-------+------+
2 rows in set (0.01 sec)
# Henry 是女性中的第一条记录
# Dany 是男性中的第一条记录
```

结果中只显示了两条记录，这两条记录的 sex 字段的值分别为“女”和“男”。

##### GROUP_CONCAT()

GROUP BY 关键字可以和 GROUP_CONCAT() 函数一起使用。GROUP_CONCAT() 函数会把每个分组的字段值都显示出来。

```mysql
mysql> SELECT `sex`, GROUP_CONCAT(name) FROM tb_students_info
    -> GROUP BY sex;
+------+----------------------------+
| sex  | GROUP_CONCAT(name)         |
+------+----------------------------+
| 女   | Henry,Jim,John,Thomas,Tom  |
| 男   | Dany,Green,Jane,Lily,Susan |
+------+----------------------------+
2 rows in set (0.00 sec)
```

```mysql
mysql> SELECT age,sex,GROUP_CONCAT(name) FROM tb_students_info
    -> GROUP BY age,sex;
+------+------+--------------------+
| age  | sex  | GROUP_CONCAT(name) |
+------+------+--------------------+
|   21 | 女   | John               |
|   22 | 女   | Thomas             |
|   22 | 男   | Jane,Lily          |
|   23 | 女   | Henry,Tom          |
|   23 | 男   | Green,Susan        |
|   24 | 女   | Jim                |
|   25 | 男   | Dany               |
+------+------+--------------------+
7 rows in set (0.00 sec)
```

上面实例在分组过程中，先按照 age 字段进行分组，当 age 字段值相等时，再把 age 字段值相等的记录按照 sex 字段进行分组。

##### 聚合函数

聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()。其中，COUNT() 用来统计记录的条数；SUM() 用来计算字段值的总和；AVG() 用来计算字段值的平均值；MAX() 用来查询字段的最大值；MIN() 用来查询字段的最小值。

```mysql
mysql> SELECT sex,COUNT(sex) FROM tb_students_info
    -> GROUP BY sex;
+------+------------+
| sex  | COUNT(sex) |
+------+------------+
| 女   |          5 |
| 男   |          5 |
+------+------------+
2 rows in set (0.00 sec)
```

##### WITH ROLLUP

```mysql
mysql> SELECT sex,GROUP_CONCAT(name) FROM tb_students_info
    ->GROUP BY sex WITH ROLLUP;
+------+------------------------------------------------------+
| sex  | GROUP_CONCAT(name)                                   |
+------+------------------------------------------------------+
| 女   | Henry,Jim,John,Thomas,Tom                            |
| 男   | Dany,Green,Jane,Lily,Susan                           |
| NULL | Henry,Jim,John,Thomas,Tom,Dany,Green,Jane,Lily,Susan |
+------+------------------------------------------------------+
3 rows in set (0.00 sec)
```

最后一条记录的 GROUP_CONCAT(name) 字段的值刚好是上面分组 name 字段值的总和。

##### HAVING 过滤分组

HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。

但是 WHERE 和 HAVING 关键字也存在以下几点差异：

-   一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤**分组**。
-   WHERE 查询条件中不可以使用**聚合函数**，而 HAVING 查询条件中可以使用聚合函数。
-   WHERE 在数据分组前进行过滤，而 HAVING 在数据**分组后**进行过滤 。
-   WHERE 针对数据库文件进行过滤，而 HAVING 针对**查询结果**进行过滤。也就是说，WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面已经查询出的字段进行过滤。
-   WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。

```mysql
mysql> SELECT name,sex,height FROM tb_students_info
    -> HAVING height>150;
mysql> SELECT name,sex,height FROM tb_students_info
    -> WHERE height>150;

# 同一结果
+--------+------+--------+
| name   | sex  | height |
+--------+------+--------+
| Dany   | 男   |    160 |
| Green  | 男   |    158 |
| Henry  | 女   |    185 |
| Jane   | 男   |    162 |
| Jim    | 女   |    175 |
| John   | 女   |    172 |
| Lily   | 男   |    165 |
| Susan  | 男   |    170 |
| Thomas | 女   |    178 |
| Tom    | 女   |    165 |
+--------+------+--------+
10 rows in set (0.00 sec)
```

```mysql
mysql> SELECT name,sex FROM tb_students_info
    -> WHERE height>150;
+--------+------+
| name   | sex  |
+--------+------+
| Dany   | 男   |
| Green  | 男   |
| Henry  | 女   |
| Jane   | 男   |
| Jim    | 女   |
| John   | 女   |
| Lily   | 男   |
| Susan  | 男   |
| Thomas | 女   |
| Tom    | 女   |
+--------+------+
10 rows in set (0.00 sec)

# height没有被查询，出错
mysql> SELECT name,sex FROM tb_students_info HAVING height>150;
ERROR 1054 (42S22): Unknown column 'height' in 'having clause'
```

### 多表查询

#### CROSS JOIN 交叉连接

交叉连接（CROSS JOIN）一般用来返回连接表的**笛卡尔积**。

```mysql
SELECT <字段名> FROM <表1> CROSS JOIN <表2> [WHERE子句]
# SELECT <字段名> FROM <表1>, <表2> [WHERE子句]
```

以上两种语法的返回结果是相同的，但是第一种语法才是官方建议的标准写法。

```mysql
mysql> SELECT * FROM tb_students_info;
+----+--------+------+------+--------+-----------+
| id | name   | age  | sex  | height | course_id |
+----+--------+------+------+--------+-----------+
|  1 | Dany   |   25 | 男   |    160 |         1 |
|  2 | Green  |   23 | 男   |    158 |         2 |
|  3 | Henry  |   23 | 女   |    185 |         1 |
|  4 | Jane   |   22 | 男   |    162 |         3 |
|  5 | Jim    |   24 | 女   |    175 |         2 |
|  6 | John   |   21 | 女   |    172 |         4 |
|  7 | Lily   |   22 | 男   |    165 |         4 |
|  8 | Susan  |   23 | 男   |    170 |         5 |
|  9 | Thomas |   22 | 女   |    178 |         5 |
| 10 | Tom    |   23 | 女   |    165 |         5 |
+----+--------+------+------+--------+-----------+
10 rows in set (0.00 sec)
```

```mysql
mysql> SELECT * FROM tb_course;
+----+-------------+
| id | course_name |
+----+-------------+
|  1 | Java        |
|  2 | MySQL       |
|  3 | Python      |
|  4 | Go          |
|  5 | C++         |
+----+-------------+
5 rows in set (0.00 sec)
```

```mysql
mysql> SELECT * FROM tb_course CROSS JOIN tb_students_info
    -> WHERE tb_students_info.course_id = tb_course.id;
+----+-------------+----+--------+------+------+--------+-----------+
| id | course_name | id | name   | age  | sex  | height | course_id |
+----+-------------+----+--------+------+------+--------+-----------+
|  1 | Java        |  1 | Dany   |   25 | 男   |    160 |         1 |
|  2 | MySQL       |  2 | Green  |   23 | 男   |    158 |         2 |
|  1 | Java        |  3 | Henry  |   23 | 女   |    185 |         1 |
|  3 | Python      |  4 | Jane   |   22 | 男   |    162 |         3 |
|  2 | MySQL       |  5 | Jim    |   24 | 女   |    175 |         2 |
|  4 | Go          |  6 | John   |   21 | 女   |    172 |         4 |
|  4 | Go          |  7 | Lily   |   22 | 男   |    165 |         4 |
|  5 | C++         |  8 | Susan  |   23 | 男   |    170 |         5 |
|  5 | C++         |  9 | Thomas |   22 | 女   |    178 |         5 |
|  5 | C++         | 10 | Tom    |   23 | 女   |    165 |         5 |
+----+-------------+----+--------+------+------+--------+-----------+
10 rows in set (0.01 sec)
```

如果在交叉连接时使用 WHERE 子句，MySQL 会**先生成两个表的笛卡尔积**，然后再选择满足 WHERE 条件的记录。表的数量较多时，交叉连接会非常非常慢。

当连接的表之间没有关系时，我们会省略掉 WHERE 子句，这时返回结果就是两个表的笛卡尔积，返回结果数量就是两个表的数据行相乘。需要注意的是，如果每个表有 1000 行，那么返回结果的数量就有 1000×1000 = 1000000 行，数据量是非常巨大的。

通过交叉连接的方式进行多表查询的这种方法并不常用，我们应该尽量避免这种查询。

#### INNER JOIN 内连接

内连接（INNER JOIN）主要通过设置连接条件的方式，来移除查询结果中某些数据行的交叉连接。简单来说，就是利用条件表达式来消除交叉连接的某些数据行。

内连接使用 **INNER JOIN** 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。

```mysql
SELECT <字段名> FROM <表1> INNER JOIN <表2> [ON子句]
```

语法说明如下。

-   字段名：需要查询的字段名称。
-   <表 1><表 2>：需要内连接的表名。
-   INNER JOIN ：内连接中可以省略 INNER 关键字，只用关键字 JOIN。
-   ON 子句：用来设置内连接的连接条件。

> INNER JOIN 也可以使用 WHERE 子句指定连接条件，但是 INNER JOIN ... ON 语法是官方的标准写法，而且 WHERE 子句在某些时候会影响查询的性能。

多个表内连接时，在 FROM 后连续使用 INNER JOIN 或 JOIN 即可。

```mysql
mysql> SELECT s.name,c.course_name FROM tb_students_info s INNER JOIN tb_course c
    -> ON s.course_id = c.id;
+--------+-------------+
| name   | course_name |
+--------+-------------+
| Dany   | Java        |
| Green  | MySQL       |
| Henry  | Java        |
| Jane   | Python      |
| Jim    | MySQL       |
| John   | Go          |
| Lily   | Go          |
| Susan  | C++         |
| Thomas | C++         |
| Tom    | C++         |
+--------+-------------+
10 rows in set (0.00 sec)
```

注意：**当对多个表进行查询时，要在 SELECT 语句后面指定字段是来源于哪一张表**。因此，在多表查询时，SELECT 语句后面的写法是`表名.列名`。另外，如果表名非常长的话，也可以给表设置别名，这样就可以直接在 SELECT 语句后面写上`表的别名.列名`。

```mysql
# 多表
SELECT s.ID, s.Name, co.CourseName, ch.Score
FROM (
    Choose AS ch
    INNER JOIN
    Course AS co
    ON ch.CourseID = co.CourseID
) INNER JOIN Student AS s
ON s.ID = ch.ID;
```

#### LEFT/RIGHT JOIN 外连接

##### 左（外）连接

```mysql
SELECT <字段名> FROM <表1> LEFT OUTER JOIN <表2> <ON子句>
```

语法说明如下。

-   字段名：需要查询的字段名称。
-   <表 1><表 2>：需要左连接的表名。
-   LEFT OUTER JOIN：左连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN。
-   ON 子句：用来设置左连接的连接条件，不能省略。

上述语法中，“表 1”为基表，“表 2”为参考表。左连接查询时，可以查询出“表 1”中的所有记录和“表 2”中匹配连接条件的记录。如果“表 1”的某行在“表 2”中没有匹配行，那么在返回结果中，“表 2”的字段值均为空值（NULL）。

```mysql
mysql> SELECT * FROM tb_course;
+----+-------------+
| id | course_name |
+----+-------------+
|  1 | Java        |
|  2 | MySQL       |
|  3 | Python      |
|  4 | Go          |
|  5 | C++         |
|  6 | HTML        |
+----+-------------+
6 rows in set (0.00 sec)

mysql> SELECT * FROM tb_students_info;
+----+--------+------+------+--------+-----------+
| id | name   | age  | sex  | height | course_id |
+----+--------+------+------+--------+-----------+
|  1 | Dany   |   25 | 男   |    160 |         1 |
|  2 | Green  |   23 | 男   |    158 |         2 |
|  3 | Henry  |   23 | 女   |    185 |         1 |
|  4 | Jane   |   22 | 男   |    162 |         3 |
|  5 | Jim    |   24 | 女   |    175 |         2 |
|  6 | John   |   21 | 女   |    172 |         4 |
|  7 | Lily   |   22 | 男   |    165 |         4 |
|  8 | Susan  |   23 | 男   |    170 |         5 |
|  9 | Thomas |   22 | 女   |    178 |         5 |
| 10 | Tom    |   23 | 女   |    165 |         5 |
| 11 | LiMing |   22 | 男   |    180 |         7 |
+----+--------+------+------+--------+-----------+
11 rows in set (0.00 sec)
```

在 tb_students_info 表和 tb_course 表中查询所有学生姓名和相对应的课程名称，包括没有课程的学生，SQL 语句和运行结果如下。

```mysql
mysql> SELECT s.name,c.course_name FROM tb_students_info s LEFT OUTER JOIN tb_course c
    -> ON s.`course_id`=c.`id`;
+--------+-------------+
| name   | course_name |
+--------+-------------+
| Dany   | Java        |
| Henry  | Java        |
| NULL   | Java        |
| Green  | MySQL       |
| Jim    | MySQL       |
| Jane   | Python      |
| John   | Go          |
| Lily   | Go          |
| Susan  | C++         |
| Thomas | C++         |
| Tom    | C++         |
| LiMing | NULL        |
+--------+-------------+
12 rows in set (0.00 sec)
```

可以看到，运行结果显示了 12 条记录，name 为 LiMing 的学生目前没有课程，因为对应的 tb_course 表中没有该学生的课程信息，所以该条记录只取出了 tb_students_info 表中相应的值，而从 tb_course 表中取出的值为 NULL。

##### 右（外）连接

```mysql
SELECT <字段名> FROM <表1> RIGHT OUTER JOIN <表2> <ON子句>
```

-   RIGHT OUTER JOIN：右连接中可以省略 OUTER 关键字，只使用关键字 RIGHT JOIN。
-   ON 子句：用来设置右连接的连接条件，不能省略。

与左连接相反，右连接以“表 2”为基表，“表 1”为参考表。右连接查询时，可以查询出“表 2”中的所有记录和“表 1”中匹配连接条件的记录。如果“表 2”的某行在“表 1”中没有匹配行，那么在返回结果中，“表 1”的字段值均为空值（NULL）。

```mysql
mysql> SELECT s.name,c.course_name FROM tb_students_info s RIGHT OUTER JOIN tb_course c
    -> ON s.`course_id`=c.`id`;
+--------+-------------+
| name   | course_name |
+--------+-------------+
| Dany   | Java        |
| Green  | MySQL       |
| Henry  | Java        |
| Jane   | Python      |
| Jim    | MySQL       |
| John   | Go          |
| Lily   | Go          |
| Susan  | C++         |
| Thomas | C++         |
| Tom    | C++         |
| NULL   | HTML        |
+--------+-------------+
11 rows in set (0.00 sec)
```

可以看到，结果显示了 11 条记录，名称为 HTML 的课程目前没有学生，因为对应的 tb_students_info 表中并没有该学生的信息，所以该条记录只取出了 tb_course 表中相应的值，而从 tb_students_info 表中取出的值为 NULL。

> 多个表左/右连接时，在 ON 子句后连续使用 LEFT/RIGHT OUTER JOIN 或 LEFT/RIGHT JOIN 即可。

使用外连接查询时，一定要分清需要查询的结果，是需要显示左表的全部记录还是右表的全部记录，然后选择相应的左连接和右连接。

### 子查询

子查询是 MySQL 中比较常用的查询方法，通过子查询可以实现多表查询。**子查询指将一个查询语句嵌套在另一个查询语句中**。子查询可以在 SELECT、UPDATE 和 DELETE 语句中使用，而且可以进行多层嵌套。在实际开发时，子查询经常出现在 WHERE 子句中。

子查询在 WHERE 中的语法格式如下：

```mysql
WHERE <表达式> <操作符> (子查询)
```

其中，操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。

#### IN | NOT IN

当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = 'Java');
+-------+
| name  |
+-------+
| Dany  |
| Henry |
+-------+
2 rows in set (0.01 sec)
```

等价于以下两条语句：

```mysql
mysql> SELECT id FROM tb_course
    -> WHERE course_name = 'Java';
+----+
| id |
+----+
|  1 |
+----+
1 row in set (0.00 sec)
# 首先单独执行内查询，查询出 tb_course 表中课程为 Java 的 id

mysql> SELECT name FROM tb_students_info
    -> WHERE course_id IN (1);
+-------+
| name  |
+-------+
| Dany  |
| Henry |
+-------+
2 rows in set (0.00 sec)
# 然后执行外层查询，在 tb_students_info 表中查询 course_id 等于 1 的学生姓名
```

习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：先执行子查询，再执行父查询。

在 SELECT 语句中使用 NOT IN 关键字，查询没有学习 Java 课程的学生姓名，SQL 语句和运行结果如下。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE course_id NOT IN (SELECT id FROM tb_course WHERE course_name = 'Java');
+--------+
| name   |
+--------+
| Green  |
| Jane   |
| Jim    |
| John   |
| Lily   |
| Susan  |
| Thomas |
| Tom    |
| LiMing |
+--------+
9 rows in set (0.01 sec)
```

#### 三个特殊运算符

使用`=`运算符，在 tb_course 表和 tb_students_info 表中查询出所有学习 Python 课程的学生姓名，SQL 语句和运行结果如下。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE course_id = (SELECT id FROM tb_course WHERE course_name = 'Python');
+------+
| name |
+------+
| Jane |
+------+
1 row in set (0.00 sec)
```

使用`<>`运算符，在 tb_course 表和 tb_students_info 表中查询出没有学习 Python 课程的学生姓名，SQL 语句和运行结果如下。

```mysql
mysql> SELECT name FROM tb_students_info
    -> WHERE course_id <> (SELECT id FROM tb_course WHERE course_name = 'Python');
+--------+
| name   |
+--------+
| Dany   |
| Green  |
| Henry  |
| Jim    |
| John   |
| Lily   |
| Susan  |
| Thomas |
| Tom    |
| LiMing |
+--------+
10 rows in set (0.00 sec)
```

#### EXISTS | NOT EXISTS

用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。

查询 tb_course 表中是否存在 id=1 的课程，如果存在，就查询出 tb_students_info 表中的记录，SQL 语句和运行结果如下。

```mysql
mysql> SELECT * FROM tb_students_info
    -> WHERE EXISTS(SELECT course_name FROM tb_course WHERE id=1);
+----+--------+------+------+--------+-----------+
| id | name   | age  | sex  | height | course_id |
+----+--------+------+------+--------+-----------+
|  1 | Dany   |   25 | 男   |    160 |         1 |
|  2 | Green  |   23 | 男   |    158 |         2 |
|  3 | Henry  |   23 | 女   |    185 |         1 |
|  4 | Jane   |   22 | 男   |    162 |         3 |
|  5 | Jim    |   24 | 女   |    175 |         2 |
|  6 | John   |   21 | 女   |    172 |         4 |
|  7 | Lily   |   22 | 男   |    165 |         4 |
|  8 | Susan  |   23 | 男   |    170 |         5 |
|  9 | Thomas |   22 | 女   |    178 |         5 |
| 10 | Tom    |   23 | 女   |    165 |         5 |
| 11 | LiMing |   22 | 男   |    180 |         7 |
+----+--------+------+------+--------+-----------+
11 rows in set (0.01 sec)
```

由结果可以看到，tb_course 表中存在 id=1 的记录，因此 EXISTS 表达式返回 TRUE，外层查询语句接收 TRUE 之后对表 tb_students_info 进行查询，返回所有的记录。

查询 tb_course 表中是否存在 id=1 的课程，如果存在，就查询出 tb_students_info 表中 age 字段大于 24 的记录，SQL 语句和运行结果如下。

```mysql
mysql> SELECT * FROM tb_students_info
    -> WHERE age>24 AND EXISTS(SELECT course_name FROM tb_course WHERE id=1);
+----+------+------+------+--------+-----------+
| id | name | age  | sex  | height | course_id |
+----+------+------+------+--------+-----------+
|  1 | Dany |   25 | 男   |    160 |         1 |
+----+------+------+------+--------+-----------+
1 row in set (0.01 sec)
```

EXISTS 关键字可以和其它查询条件一起使用，条件表达式与 EXISTS 关键字之间用 AND 和 OR 连接。

子查询的功能也可以通过表连接完成，但是子查询会使 SQL 语句更容易阅读和编写。

一般来说，表连接（内连接和外连接等）都可以用子查询替换，但反过来却不一定，有的子查询不能用表连接来替换。子查询比较灵活、方便、形式多样，适合作为查询的筛选条件，而表连接更适合于查看连接表的数据。

#### 注意事项

##### 嵌套在 SQL 语句中任何表达式出现的位置

嵌套在 SELECT 语句的 SELECT 子句中的子查询语法格式如下。

```mysql
SELECT (子查询) FROM 表名;
```

提示：子查询结果为单行单列，但不必指定列别名。

嵌套在 SELECT 语句的 FROM 子句中的子查询语法格式如下。

```mysql
SELECT * FROM (子查询) AS 表的别名;
```

**注意：必须为表指定别名。一般返回多行多列数据记录，可以当作一张临时表。**

##### 只出现在子查询中而没有出现在父查询中的表不能包含在输出列中

多层嵌套子查询的最终数据集只包含父查询（即最外层的查询）的 SELECT 子句中出现的字段，而子查询的输出结果通常会作为其外层子查询数据源或用于数据判断匹配。

### 正则表达式查询

```mysql
属性名 REGEXP '匹配方式'
```

```mysql
mysql> SELECT * FROM tb_students_info
    -> WHERE name REGEXP '^J';
+----+------+------+------+--------+-----------+
| id | name | age  | sex  | height | course_id |
+----+------+------+------+--------+-----------+
|  4 | Jane |   22 | 男   |    162 |         3 |
|  5 | Jim  |   24 | 女   |    175 |         2 |
|  6 | John |   21 | 女   |    172 |         4 |
+----+------+------+------+--------+-----------+
3 rows in set (0.01 sec)
```

```mysql
mysql> SELECT * FROM tb_students_info
    -> WHERE name REGEXP 'a.y';
+----+------+------+------+--------+-----------+
| id | name | age  | sex  | height | course_id |
+----+------+------+------+--------+-----------+
|  1 | Dany |   25 | 男   |    160 |         1 |
+----+------+------+------+--------+-----------+
1 row in set (0.00 sec)
```

```mysql
mysql> SELECT * FROM tb_students_info
    -> WHERE name REGEXP '^Th+';
+----+--------+------+------+--------+-----------+
| id | name   | age  | sex  | height | course_id |
+----+--------+------+------+--------+-----------+
|  9 | Thomas |   22 | 女   |    178 |         5 |
+----+--------+------+------+--------+-----------+
1 row in set (0.00 sec)
```

```mysql
mysql> SELECT * FROM tb_students_info WHERE name REGEXP 'i{1,3}';
+----+--------+------+------+--------+-----------+
| id | name   | age  | sex  | height | course_id |
+----+--------+------+------+--------+-----------+
|  5 | Jim    |   24 | 女   |    175 |         2 |
|  7 | Lily   |   22 | 男   |    165 |         4 |
| 11 | LiMing |   22 | 男   |    180 |         7 |
+----+--------+------+------+--------+-----------+
3 rows in set (0.00 sec)
```

### 插入数据

#### INSERT…VALUES 语句

```mysql
INSERT INTO <表名> [ <列名1> [ , … <列名n>] ]
VALUES (值1) [… , (值n) ];
```

-   `<表名>`：指定被操作的表名。
-   `<列名>`：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT<表名>VALUES(…) 即可。
-   `VALUES` 或 `VALUE` 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。

插入数据时，不需要按照表定义的顺序插入，只要保证值的顺序与列字段的顺序相同就可以。

#### INSERT…SET 语句

```mysql
INSERT INTO <表名>
SET <列名1> = <值1>,
        <列名2> = <值2>,
        …
```

此语句用于直接给表中的某些列指定对应的列值，即要插入的数据的列名在 SET 子句中指定，col_name 为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。

由 INSERT 语句的两种形式可以看出：

-   使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；
-   使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；
-   INSERT…SELECT 语句向表中插入其他表的数据。
-   采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；
-   INSERT…VALUES 语句可以一次插入多条数据。

在 MySQL 中，用单条 INSERT 语句处理多个插入要比使用多条 INSERT 语句更快。

当使用单条 INSERT 语句插入多行数据的时候，只需要将每行数据用圆括号括起来即可。

#### 例子

```mysql
mysql> INSERT INTO tb_courses
    -> (course_id,course_name,course_grade,course_info)
    -> VALUES(1,'Network',3,'Computer Network');
Query OK, 1 rows affected (0.08 sec)
mysql> SELECT * FROM tb_courses;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            3 | Computer Network |
+-----------+-------------+--------------+------------------+
1 row in set (0.00 sec)
```

```mysql
mysql> INSERT INTO tb_courses
    -> VLAUES(3,'Java',4,'Java EE');
Query OK, 1 rows affected (0.08 sec)
mysql> SELECT * FROM tb_courses;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            3 | Computer Network |
|         2 | Database    |            3 | MySQL            |
|         3 | Java        |            4 | Java EE          |
+-----------+-------------+--------------+------------------+
3 rows in set (0.00 sec)
```

INSERT 语句中没有指定插入列表，只有一个值列表。在这种情况下，值列表为每一个字段列指定插入的值，并且这些值的顺序必须和 tb_courses 表中字段定义的顺序相同。

```mysql
mysql> INSERT INTO tb_courses
    -> (course_name,course_grade,course_info)
    -> VALUES('System',3,'Operation System');
Query OK, 1 rows affected (0.08 sec)
mysql> SELECT * FROM tb_courses;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            3 | Computer Network |
|         2 | Database    |            3 | MySQL            |
|         3 | Java        |            4 | Java EE          |
|         4 | System      |            3 | Operating System |
+-----------+-------------+--------------+------------------+
4 rows in set (0.00 sec)
```

可以看到插入记录成功。如查询结果显示，这里的 course_id 字段自动添加了一个整数值 4。这时的 course_id 字段为表的主键，不能为空，系统自动为该字段插入自增的序列值。在插入记录时，如果某些字段没有指定插入值，MySQL 将插入该字段定义时的默认值。

#### 使用 INSERT INTO…FROM 语句复制表数据

INSERT INTO…SELECT…FROM 语句用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。

SELECT 子句返回的是一个查询到的结果集，INSERT 语句将这个结果集插入指定表中，**结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致**。

```mysql
mysql> INSERT INTO tb_courses_new
    -> (course_id,course_name,course_grade,course_info)
    -> SELECT course_id,course_name,course_grade,course_info
    -> FROM tb_courses;
Query OK, 4 rows affected (0.17 sec)
Records: 4  Duplicates: 0  Warnings: 0
mysql> SELECT * FROM tb_courses_new;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            3 | Computer Network |
|         2 | Database    |            3 | MySQL            |
|         3 | Java        |            4 | Java EE          |
|         4 | System      |            3 | Operating System |
+-----------+-------------+--------------+------------------+
4 rows in set (0.00 sec)
```

### 修改数据 UPDATE

```mysql
UPDATE <表名> SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ]
[ORDER BY 子句] [LIMIT 子句]
```

语法说明如下：

-   `<表名>`：用于指定要更新的表名称。
-   `SET` 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。
-   `WHERE` 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。
-   `ORDER BY` 子句：可选项。用于限定表中的行被修改的次序。
-   `LIMIT` 子句：可选项。用于限定被修改的行数。

> 注意：修改一行数据的多个列值时，SET 子句的每个值用逗号分开即可。

```mysql
mysql> UPDATE tb_courses_new
    -> SET course_grade=4;
Query OK, 3 rows affected (0.11 sec)
Rows matched: 4  Changed: 3  Warnings: 0
mysql> SELECT * FROM tb_courses_new;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            4 | Computer Network |
|         2 | Database    |            4 | MySQL            |
|         3 | Java        |            4 | Java EE          |
|         4 | System      |            4 | Operating System |
+-----------+-------------+--------------+------------------+
4 rows in set (0.00 sec)
```

```mysql
mysql> UPDATE tb_courses_new
    -> SET course_name='DB',course_grade=3.5
    -> WHERE course_id=2;
Query OK, 1 row affected (0.13 sec)
Rows matched: 1  Changed: 1  Warnings: 0
mysql> SELECT * FROM tb_courses_new;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            4 | Computer Network |
|         2 | DB          |          3.5 | MySQL            |
|         3 | Java        |            4 | Java EE          |
|         4 | System      |            4 | Operating System |
+-----------+-------------+--------------+------------------+
4 rows in set (0.00 sec)
```

注意：保证 UPDATE 以 WHERE 子句结束，通过 WHERE 子句指定被更新的记录所需要满足的条件，如果忽略 WHERE 子句，MySQL 将更新表中所有的行。

### 删除数据 DELETE

```mysql
DELETE FROM <表名> [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]
```

语法说明如下：

-   `<表名>`：指定要删除数据的表名。
-   `ORDER BY` 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。
-   `WHERE` 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。
-   `LIMIT` 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。

**注意：在不使用 WHERE 条件的时候，将删除所有数据。**

```mysql
mysql> DELETE FROM tb_courses_new;
Query OK, 3 rows affected (0.12 sec)
mysql> SELECT * FROM tb_courses_new;
Empty set (0.00 sec)
```

```mysql
mysql> DELETE FROM tb_courses
    -> WHERE course_id=4;
Query OK, 1 row affected (0.00 sec)
mysql> SELECT * FROM tb_courses;
+-----------+-------------+--------------+------------------+
| course_id | course_name | course_grade | course_info      |
+-----------+-------------+--------------+------------------+
|         1 | Network     |            3 | Computer Network |
|         2 | Database    |            3 | MySQL            |
|         3 | Java        |            4 | Java EE          |
+-----------+-------------+--------------+------------------+
3 rows in set (0.00 sec)
```

## 注释

### 单行注释

-   `#`:

```mysql
#从结果中删除重复行
SELECT DISTINCT product_id, purchase_price FROM Product;
```

-   `-- `:

```sql
-- 从结果中删除重复行，--后面要有一个空格
SELECT DISTINCT product_id, purchase_price FROM Product;
```

### 多行注释

```mysql
/*这条SELECT语句，
  会从结果中删除重复行*/
SELECT DISTINCT product_id, purchase_price FROM Product;
```

任何注释（单行注释和多行注释）都可以插在 SQL 语句中，且注释可以放在 SQL 语句中的任意位置。

## 大小写区分

1. SQL 的**关键字**和**函数名**不区分大小写；
2. **数据库名**和**表名**的默认大小写取决于服务器主机的操作系统在命名方面的规定。Windows 系统的文件名不区分大小写，所以运行在 Windows 系统上面的 MySQL 服务器也不用区分数据库名和表名的大小写。Linux 系统的文件名区分大小写，所以运行在 Linux 系统上的 MySQL 服务器需要区分数据库名和表名的大小写。对于 Mac OS X 平台，其文件系统中的名字是个例外，它们不区分大小写。
3. **存储函数**、**存储过程**和**事件**的名字都不区分大小写。触发器的名字要区分大小写，这一点与标准 SQL 的行为有所不同。
4. **列名**和**索引名**都不区分大小写。例如，下面这些语句都是等价的：

```mysql
SELECT name FROM student;
SELECT NAME FROM student;
SELECT nAmE FROM student;
```

5. 默认情况下，表的别名要区分大小写。SQL 语句中可以使用任意的大小写（大写、小写或大小写混用）来指定一个别名。如果需要在同一条语句里多次用到同一个别名，则必须让它们的大小写保持一致。

|          | Windows          | Linux            |
| -------- | ---------------- | ---------------- |
| 数据库名 | 否（忽略大小写） | 是               |
| 表名     | 否（忽略大小写） | 是               |
| 表别名   | 否（忽略大小写） | 是               |
| 列名     | 否（忽略大小写） | 否（忽略大小写） |
| 列别名   | 否（忽略大小写） | 否（忽略大小写） |
| 变量名   | 否（忽略大小写） | 是               |

在 Linux 服务器下创建数据库和表时，应该认真考虑大小写的问题，比如它们以后是否会迁移到 Windows 服务器上。

假设你在 Linux 服务器上创建了 abc 和 ABC 两个表，当把这两个表迁移到 Windows 服务器上时，就会出现问题；因为 Windows 系统并不区分大小写，abc 和 ABC 无差别。如果把表从 Linux 服务器迁移到 Windows 服务器时，也同样会遇到问题。

想要避免大小写问题，可以先选定一种大小写方案，然后一直按照该方案去创建数据库和表。

## 为表和字段指定别名(仅查询)

### 为表指定别名

```mysql
<表名> [AS] <别名>
```

```mysql
mysql> SELECT stu.name,stu.height FROM tb_students_info AS stu;
```

### 为字段指定别名

```mysql
<字段名> [AS] <别名>
```

```sql
mysql> SELECT name AS student_name, age AS student_age FROM tb_students_info;
```

注意：**表别名只在执行查询时使用**，并不在返回结果中显示。而字段定义别名之后，会返回给客户端显示，显示的字段为字段的别名。
