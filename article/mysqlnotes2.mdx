---
title: "Mysql 基础(II)"
categories: ["Database"]
date: "2020-05-07"
last-modified: "2022-10-10"
brief-description: ""
---

import { Quotes } from "../src/components/Quotes.js";

## 视图 View

MySQL 视图（View）是一种虚拟存在的表，同真实表一样，视图也由列和行构成，但视图并不实际存在于数据库中。数据库中只存放了视图的定义，并没有存放视图中的数据，这些数据都存放在定义视图查询所引用的真实表中。使用视图查询数据时，数据库会从真实表中取出对应的数据。

因此，视图中的数据是依赖于真实表中的数据的。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。

视图可以从原有的表上选取对用户有用的信息，那些对用户没用，或者用户没有权限了解的信息，都可以直接屏蔽掉，作用类似于筛选。这样做既使应用简单化，也保证了系统的安全。

> 技巧：如果经常需要从多个表查询指定字段的数据，可以在这些表上建立一个视图，通过这个视图显示这些字段的数据。

视图并不同于数据表，它们的区别在于以下几点：

-   视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。
-   存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时**动态生成这些数据**。
-   视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。
-   视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。
-   视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，**只是一些 SQL 语句的集合**。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。
-   视图的建立和删除只影响视图本身，不影响对应的基本表。

**视图本质上提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义动态地从基础表中检索出来的。**

使用视图的时候，还应该注意以下几点：

-   创建视图需要足够的访问权限。
-   创建视图的数目没有限制。
-   视图可以嵌套，即从其他视图中检索数据的查询来创建视图。
-   视图不能索引，也不能有关联的触发器、默认值或规则。
-   视图可以和表一起使用。
-   视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。

> 提示：ORDER BY 子句可以用在视图中，但若该视图检索数据的 SELECT 语句中也含有 ORDER BY 子句，则该视图中的 ORDER BY 子句将被覆盖。

### 创建视图(CREATE VIEW)

视图可以建立在一张表中，也可以建立在多张表中。

```mysql
CREATE VIEW <视图名> AS <SELECT语句>
```

-   `<视图名>`：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。
-   `<SELECT语句>`：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。

对于创建视图中的 SELECT 语句的指定存在以下限制：

-   用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。
-   SELECT 语句不能引用系统或用户变量。
-   SELECT 语句不能包含 FROM 子句中的子查询。
-   SELECT 语句不能引用预处理语句参数。

视图定义中引用的表或视图必须存在。但是，创建完视图后，可以删除定义引用的表或视图。可使用 CHECK TABLE 语句检查视图定义是否存在这类问题。

视图定义中允许使用 ORDER BY 语句，但是若从特定视图进行选择，而该视图使用了自己的 ORDER BY 语句，则视图定义中的 ORDER BY 将被忽略。

视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。

WITH CHECK OPTION 的意思是，修改视图时，检查插入的数据是否符合 WHERE 设置的条件。

```mysql
mysql> CREATE VIEW view_students_info
    -> AS SELECT * FROM tb_students_info;
Query OK, 0 rows affected (0.00 sec)
mysql> SELECT * FROM view_students_info;
+----+--------+---------+------+------+--------+------------+
| id | name   | dept_id | age  | sex  | height | login_date |
+----+--------+---------+------+------+--------+------------+
|  1 | Dany   |       1 |   25 | F    |    160 | 2015-09-10 |
|  2 | Green  |       3 |   23 | F    |    158 | 2016-10-22 |
|  3 | Henry  |       2 |   23 | M    |    185 | 2015-05-31 |
|  4 | Jane   |       1 |   22 | F    |    162 | 2016-12-20 |
|  5 | Jim    |       1 |   24 | M    |    175 | 2016-01-15 |
|  6 | John   |       2 |   21 | M    |    172 | 2015-11-11 |
|  7 | Lily   |       6 |   22 | F    |    165 | 2016-02-26 |
|  8 | Susan  |       4 |   23 | F    |    170 | 2015-10-01 |
|  9 | Thomas |       3 |   22 | M    |    178 | 2016-06-07 |
| 10 | Tom    |       4 |   23 | M    |    165 | 2016-08-05 |
+----+--------+---------+------+------+--------+------------+
10 rows in set (0.04 sec)
```

默认情况下，创建的视图和基本表的字段是一样的，也可以通过指定视图字段的名称来创建视图。

```mysql
mysql> CREATE VIEW v_students_info
    -> (s_id,s_name,d_id,s_age,s_sex,s_height,s_date)
    -> AS SELECT id,name,dept_id,age,sex,height,login_date
    -> FROM tb_students_info;
Query OK, 0 rows affected (0.06 sec)
mysql> SELECT * FROM v_students_info;
+------+--------+------+-------+-------+----------+------------+
| s_id | s_name | d_id | s_age | s_sex | s_height | s_date     |
+------+--------+------+-------+-------+----------+------------+
|    1 | Dany   |    1 |    24 | F     |      160 | 2015-09-10 |
|    2 | Green  |    3 |    23 | F     |      158 | 2016-10-22 |
|    3 | Henry  |    2 |    23 | M     |      185 | 2015-05-31 |
|    4 | Jane   |    1 |    22 | F     |      162 | 2016-12-20 |
|    5 | Jim    |    1 |    24 | M     |      175 | 2016-01-15 |
|    6 | John   |    2 |    21 | M     |      172 | 2015-11-11 |
|    7 | Lily   |    6 |    22 | F     |      165 | 2016-02-26 |
|    8 | Susan  |    4 |    23 | F     |      170 | 2015-10-01 |
|    9 | Thomas |    3 |    22 | M     |      178 | 2016-06-07 |
|   10 | Tom    |    4 |    23 | M     |      165 | 2016-08-05 |
+------+--------+------+-------+-------+----------+------------+
10 rows in set (0.01 sec)
```

view_students_info 和 v_students_info 两个视图中的字段名称不同，但是数据却相同。因此，在使用视图时，可能用户不需要了解基本表的结构，更接触不到实际表中的数据，从而保证了数据库的安全。

#### 创建多表视图

见多表查询，可以使用交叉连接，内连接，外连接来完成 SELECT 语句：

```mysql
mysql> CREATE VIEW view_stu_dept_info
    -> (s_id, s_name, s_dept_id, dept_name)
    -> AS SELECT tb_students_info.id, tb_students_info.name, tb_students_info.dept_id, tb_departments.name
    -> FROM tb_students_info INNER JOIN tb_departments
    -> ON tb_students_info.dept_id = tb_departments.id;
```

### 查看视图

#### DESCRIBE/DESC 查看字段信息

```mysql
DESCRIBE 视图名；
# DESC 视图名;
```

#### 查看视图详细信息(SHOW CREATE)

```mysql
SHOW CREATE VIEW 视图名[\G]
```

### 修改视图

```mysql
ALTER VIEW <视图名> AS <SELECT语句>
```

某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句**更新基本表的内容**。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。

还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：

-   聚合函数 SUM()、MIN()、MAX()、COUNT() 等。
-   DISTINCT 关键字。
-   GROUP BY 子句。
-   HAVING 子句。
-   UNION 或 UNION ALL 运算符。
-   位于选择列表中的子查询。
-   FROM 子句中的不可更新视图或包含多个表。
-   WHERE 子句中的子查询，引用 FROM 子句中的表。
-   ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。

#### 修改视图名称

修改视图的名称可以先将视图删除，然后按照相同的定义语句进行视图的创建，并命名为新的视图名称。

### 删除视图(DROP VIEW)

删除视图时，只能删除视图的定义，不会删除数据。

```mysql
DROP VIEW [IF EXISTS] <视图名1> [ , <视图名2> …]
```

## 索引

索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。

<Quotes
    quoteType="Note"
    title="索引的优缺点"
    message={
        <>
            <strong>索引的优点</strong>
            <ul>
                <li>加快数据的检索速度</li>
                <li>
                    加速表和表之间的连接，在实现数据的
                    <strong>参考完整性</strong>方面特别有意义
                </li>
                <li>
                    <strong>唯一性索引</strong>
                    ，可以保证数据库表中每一行数据的唯一性
                </li>
            </ul>
            <strong>索引的缺点</strong>
            <ul>
                <li>
                    （时间）创建和维护索引都要耗费时间，且随着数据量的增加而增加，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
                </li>
                <li>
                    （空间）除了数据表占数据空间之外，每一个索引还要占一定的物理空间，聚簇索引需要的空间更大。
                </li>
            </ul>
        </>
    }
/>

### 索引分类

#### 根据用途

1. **普通索引**：加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是 INDEX 或 KEY。
2. **唯一性索引**：唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。
3. **主键索引**：主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。
4. 空间索引：空间索引主要用于地理空间数据类型 GEOMETRY。
5. 全文索引：全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。

索引在逻辑上分为以上 5 类，但在实际使用中，索引通常被创建成单列索引和组合索引。

-   单列索引就是索引只包含原表的一个列。
-   组合索引也称为复合索引或多列索引，相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。

> 提示：
>
> 一个表可以有多个单列索引，但这些索引不是组合索引。
>
> 一个组合索引实质上为表的查询提供了**多个索引**，以此来加快查询速度。比如，在一个表中创建了一个组合索引(c1，c2，c3)，在实际查询中，系统用来实际加速的索引有三个：单个索引(c1)、双列索引(c1，c2)和多列索引(c1，c2，c3)。

#### 根据存储引擎

1. B-树索引：B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序。但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：
    - 查询必须从索引的最左边的列开始。
    - 查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。
    - 存储引擎不能使用索引中范围条件右边的列。
2. 哈希索引：HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。具体表现在将数据库字段数据转换成定长的 Hash 值，与这条数据的行指针一并存入 Hash 表的对应位置，如果发生 Hash 碰撞（两个不同关键字的 Hash 值相同），则在对应 Hash 键下以 链表形式 存储。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：
    - MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B-树索引来说，建立哈希索引会耗费更多的时间。
    - 不能使用 HASH 索引排序。
    - HASH 索引只支持等值比较，如`=`, `IN()` 或 `<=>`。
    - HASH 索引不支持键的**部分匹配**，因为在计算 HASH 值的时候是通过整个索引值来计算的。
3. 位图索引：B 树索引在处理基数较小的列时会变得很难使用。如果用户查询的列的基数非常的小，即只有几个固定值，如性别、婚姻状况、行政区等等，要么不使用索引，查询时一行行扫描所有记录，要么考虑建立位图索引。位图索引为存储在某列中的每个值生成一个位图。比如：

| Value/Row ID |  1  |  2  |  3  |  4  |  5  |
| :----------: | :-: | :-: | :-: | :-: | :-: |
|     男性     |  1  |  0  |  1  |  0  |  0  |
|     女性     |  0  |  1  |  0  |  0  |  1  |
|     其他     |  0  |  0  |  0  |  1  |  0  |

对于性别这一列，索引包含 3 个位图（横着看），即生成有 3 个向量，分别属于每一个取值，每个位图为每一个人（行）都分配了 0/1 值（每一行有且仅有一个 1 ），男性为 `10100...`，女性为 `01001...`，其他为`00010...`。当进行查找时，只要查找相关位图中的所有 1 值即可（根据查询需求搭配与、或运算）。

<Quotes
    quoteType="Warning"
    title="位图适用场景"
    message="位图索引适合固定值的列即静态数据，不适合索引频繁更新的列。"
/>

#### 聚簇索引

**聚簇索引**：将数据存储和索引放到一起，找到索引也就找到了数据。

特点：

-   索引和数据存放在一起提高了检索效率；
-   可以减少磁盘的 IO 次数；

表的物理存储依据聚簇索引的结构，所以一个数据表只能有一个聚簇索引，但可以拥有多个非聚簇索引；一般而言，会在频繁使用、排序的字段上创建聚簇索引。

**非聚簇索引**：除了聚簇索引以外的其他索引，均称之为非聚簇索引。非聚簇索引也是 B 树结构，非聚簇索引中**不存储真正的数据行**，只包含一个指向数据行的指针。

### 使用索引时需要注意

建立索引时有一些需要遵守的原则：

<Quotes
    quoteType="Suggestion"
    title="建立索引的原则"
    message={
        <ul>
            <li>在经常需要搜索的列上建立索引，可以加快搜索的速度。</li>
            <li>
                在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。
            </li>
            <li>
                在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。
            </li>
            <li>
                在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。
            </li>
            <li>
                在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。
            </li>
            <li>在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。</li>
        </ul>
    }
/>

索引的根本目的是方便查询，有的环境就不适合创建索引：

-   **使用频率低：**对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。
-   **数据量小：**对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。
-   **列内元素数据量差距较大：**对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。
-   **频繁修改：**当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

此外，有**外键**的数据列一定要创建索引。

#### 最左前缀匹配原则（仅 MySQL）

在 MySQL 建立联合索引（多列索引）时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。例如有一个 3 列索引`(a,b,c)`，则已经对`(a)`、`(a,b)`、`(a,b,c)`上建立了索引。所以在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。

根据最左前缀匹配原则，MySQL 会一直向右匹配直到遇到范围查询（`>`, `<`, `between`, `like`）就停止匹配，比如采用查询条件 `where a = 1 and b = 2 and c > 3 and d = 4` 时，如果建立`(a,b,c,d)`顺序的索引，由于优化器的存在，只有`d` 是用不到索引的，如果建立`(a,b,d,c)`的索引则都可以用到，同样归功于优化器，where 子句中 a、b、d 的顺序可以任意调整。

如果建立的索引顺序是 `(a,b)` ，那么根据最左前缀匹配原则，直接采用查询条件 `where b = 1` 是无法利用到索引的。

<Quotes
    quoteType="Note"
    title="Case study"
    message={
        <>
            <p>
                假设索引为(a,b,c)，此时相当于已经建立了三个索引：(a),(a,b),(a,b,c)
            </p>
            <table>
                <thead>
                    <tr>
                        <th>查询条件</th>
                        <th>使用索引情况</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <th>a=?</th>
                        <th>(a)</th>
                    </tr>
                    <tr>
                        <th>a=? and b=?</th>
                        <th>(a, b)</th>
                    </tr>
                    <tr>
                        <th>a=? and b=? and c=?</th>
                        <th>(a, b, c)</th>
                    </tr>
                    <tr>
                        <th>b=?</th>
                        <th>NULL</th>
                    </tr>
                    <tr>
                        <th>b=? and c=?</th>
                        <th>NULL</th>
                    </tr>
                    <tr>
                        <th>b=? and a=?</th>
                        <th>(a, b)</th>
                    </tr>
                    <tr>
                        <th>c=? and b=? and a=?</th>
                        <th>(a, b, c)</th>
                    </tr>
                    <tr>
                        <th>c=? and a=?</th>
                        <th>(a)</th>
                    </tr>
                    <tr>
                        <th>c=? and b&gt;? and a=?</th>
                        <th>(a, b)</th>
                    </tr>
                    <tr>
                        <th>c&lt;? and b=? and a=?</th>
                        <th>(a, b, c)</th>
                    </tr>
                </tbody>
            </table>
        </>
    }
/>

### 添加索引

#### 已有表时 CREATE INDEX

```mysql
CREATE INDEX <索引名> ON <表名> (<列名> [<长度>] [ASC | DESC]);
```

语法说明如下：

-   `<索引名>`：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的。
-   `<表名>`：指定要创建索引的表名。
-   `<列名>`：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。
-   `<长度>`：可选项。指定使用列前的 length 个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。
-   `ASC|DESC`：可选项。`ASC`指定索引按照升序来排列，`DESC`指定索引按照降序来排列，默认为`ASC`。

#### 创建表时 CREATE TABLE

```mysql
CONSTRAINT PRIMARY KEY [索引类型] (<列名>,…)
KEY | INDEX [<索引名>] [<索引类型>] (<列名>,…)
UNIQUE [ INDEX | KEY] [<索引名>] [<索引类型>] (<列名>,…) #唯一索引
FOREIGN KEY <索引名> <列名>
```

在使用 CREATE TABLE 语句定义列选项的时候，可以通过直接在某个列定义后面添加 PRIMARY KEY 的方式创建主键。而当主键是由多个列组成的多列索引时，则不能使用这种方法，只能用在语句的最后加上一个 `PRIMARY KEY(<列名>，…)` 子句的方式来实现。

```mysql
mysql> CREATE TABLE tb_stu_info
    -> (
    -> id INT NOT NULL,
    -> name CHAR(45) DEFAULT NULL,
    -> dept_id INT DEFAULT NULL,
    -> age INT DEFAULT NULL,
    -> height INT DEFAULT NULL,
    -> INDEX(height)
    -> );
```

```mysql
mysql> CREATE TABLE tb_stu_info2
    -> (
    -> id INT NOT NULL,
    -> name CHAR(45) DEFAULT NULL,
    -> dept_id INT DEFAULT NULL,
    -> age INT DEFAULT NULL,
    -> height INT DEFAULT NULL,
    -> UNIQUE INDEX(height)
    -> );
```

#### 修改表时 ALTER TABLE

```mysql
ADD INDEX [<索引名>] [<索引类型>] (<列名>,…)
ADD PRIMARY KEY [<索引类型>] (<列名>,…)
ADD UNIQUE [ INDEX | KEY] [<索引名>] [<索引类型>] (<列名>,…)
ADD FOREIGN KEY [<索引名>] (<列名>,…)
```

### 查看索引

```mysql
SHOW INDEX FROM <表名> [ FROM <数据库名>]
```

该语句会返回一张结果表，该表有如下几个字段，每个字段所显示的内容说明如下。

| 参数         | 说明                                                                                                                                                             |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Table        | 表示创建索引的数据表名，这里是 tb_stu_info2 数据表。                                                                                                             |
| Non_unique   | 表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。                                                                         |
| Key_name     | 表示索引的名称。                                                                                                                                                 |
| Seq_in_index | 表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。                                               |
| Column_name  | 表示定义索引的列字段。                                                                                                                                           |
| Collation    | 表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。                                                                  |
| Cardinality  | 索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。 |
| Sub_part     | 表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。                                |
| Packed       | 指示关键字如何被压缩。若没有被压缩，值为 NULL。                                                                                                                  |
| Null         | 用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。                                                                          |
| Index_type   | 显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。                                                                                                       |
| Comment      | 显示评注。                                                                                                                                                       |

```mysql
mysql> SHOW INDEX FROM tb_stu_info2\G
*************************** 1. row ***************************
        Table: tb_stu_info2
   Non_unique: 0
     Key_name: height
Seq_in_index: 1
  Column_name: height
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
1 row in set (0.03 sec)
```

### 删除和修改索引

当不再需要索引时，可以使用 DROP INDEX 语句或 ALTER TABLE 语句来对索引进行删除。

#### DROP INDEX

```mysql
DROP INDEX <索引名> ON <表名>
```

```mysql
mysql> DROP INDEX height
    -> ON tb_stu_info;
```

#### ALTER TABLE

```mysql
mysql> ALTER TABLE tb_stu_info2
    -> DROP INDEX height;
```

## 事务

**数据库的事务机制：**包含了一组数据库操作命令，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。它把所有的命令作为一个**整体**一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。如果任意一个操作失败，那么整组操作即为失败，会回到操作前状态或者是上一个节点。事务保证了逻辑数据一致性和可恢复性，锁是实现事务的关键，保证事务的完整性和并发性。

### 事务的四大特性 ACID

1. **原子性(Atomicity)：事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。**以转账事务为例，如果该事务提交了，则这两个账户的数据将会更新；如果由于某种原因，事务在成功更新这两个账户之前终止了，则不会更新这两个账户的余额，并且会 撤销 对任何账户余额的修改，回到此操作前状态，即事务不能部分提交。
2. **一致性(Consistency)：当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。**以转账事务事务为例。在事务开始之前，所有 账户余额的总额处于一致状态。在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。因此，所有账户余额的总额处于不一致状态。但是当事务完成以后，账户余额的总额再次恢复到一致状态。
3. **隔离性(Isolation)：并发访问数据库时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。**修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。
4. **持久性(Durability)：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。**

### 事务之间的相互影响

-   **脏读：一个事务读取了另一个事务未提交的数据。**事务 B 存入 100 元，此时事务 A 查余额，为 100 元，但事务 B 发生了错误，回滚了，余额又重新变成了 0，出现了不一致的情况，此时便说事务 A 读到了脏数据。
-   **不可重复读：就是在一个事务范围内，两次相同的查询会返回两个不同的数据，这是因为在此间隔内有其他事务对数据进行了修改。**事务 A 查余额，为 0，事务 B 存入 100 元并成功提交，此时事务 A 再查余额，变成了 100 元，同样的查询得到不同的结果。
-   **幻读：**幻读是指当事务不是独立执行时发生的一种现象，例如有一个事务对表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第一个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，第一个事务的用户发现表中多了一条没有修改的数据行。幻读强调的是查询结果为**多条数据**的场景。A 查余额明细，有 20 条，B 存入 100 元，使得余额明细多了一条，然后提交成功，此时 A 再查余额明细，得到了 21 条。
-   **丢失更新：**两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果**覆盖**了 A 的修改结果，导致事务 A 更新丢失。事务 A 和 B 同时开始，A 存入 100 元，B 存入 50 元，A 先于 B 提交成功，此时余额为 100，但当 B 提交成功后，余额变成了 50 元，A 对余额的更新就不见了。

### 事务的隔离级别

为尽可能避免事务之间的相互影响，实现事务的四大特性，SQL 标准定义了 4 种不同的事务隔离级别（TRANSACTION ISOLATION LEVEL），表示并发事务对同一资源的读取深度层次：

1. **读未提交：**一个事务可以读到另一个事务未提交的结果。
2. **读已提交：**只有在事务提交后，其更新结果才会被其他事务看见，可以解决脏读问题，Oracle 默认采用的是该隔离级别。
3. **可重复读：**在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交，除非数据是被本身事务自己所修改。MySQL 默认采用可重复读隔离级别。
4. **可串行化：**完全服从 ACID，牺牲了系统的并发性，所有事务依次逐个执行。

| 该隔离级别下是否可以发生 | 脏读 | 不可重复读 | 幻读 | 丢失更新 |
| :----------------------: | :--: | :--------: | :--: | :------: |
|         读未提交         |  是  |     是     |  是  |    是    |
|         读已提交         |  否  |     是     |  是  |    是    |
|         可重复读         |  否  |     否     |  是  |    否    |
|         可串行化         |  否  |     否     |  否  |    否    |

## 锁

为更好避免发生上面提到的脏读等错误，引入了对资源的锁定。锁定的存在使得一个事务对他自己的数据块进行操作时，另外一个事务不能插足这个数据块。

-   **共享锁（S）：可以并发读取数据，但不能修改数据。**也就是说当数据资源上存在共享锁时，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。
-   **排它锁（X）：对数据资源进行增删改操作时，不允许其它事务操作这块资源，直到排它锁被释放**，从而防止同时对同一资源进行多重操作。

资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排它锁，否则变为共享锁。

事务隔离级别与锁的关系对应如下：

1. **读取未提交：**读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；
2. **读取已提交：**读操作加**共享锁**，但是在语句执行完以后**释放**共享锁；
3. **可重复读：**读操作加**共享锁**，但是在事务提交之前并**不释放**共享锁，也就是必须等待事务执行完毕以后才释放共享锁；
4. **可串行化**：锁定整个范围的键，并一直持有锁，直到事务完成。

可串行化 是限制性最强的隔离级别，因为该级别 锁定整个范围的键，并一直持有锁，直到事务完成。

### 死锁

死锁：两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法：

-   不同程序并发存取多个表时，尽量以**相同的顺序**访问表，可以大大降低死锁机会；
-   同一个事务中尽量一次锁定所需要的所有资源，减少死锁产生概率；
-   对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过使用表一级的锁来减少死锁产生的概率。

<Quotes
    quoteType="Note"
    title="乐观锁和悲观锁"
    message={
        <ul>
            <li>
                <strong>悲观锁：</strong>
                假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。
            </li>
            <li>
                <strong>乐观锁：</strong>
                假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于
                <strong>读多写少</strong>
                的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或
                CAS 算法实现。
            </li>
        </ul>
    }
/>

## 存储过程

存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL 存储过程名字”即可自动完成。

存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，**一次执行成功，就可以随时被调用**，完成指定的功能操作。
